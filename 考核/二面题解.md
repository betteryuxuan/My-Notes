2024移动应用开发实验室春季二面题解

# [A 小车问题](https://www.luogu.com.cn/problem/P1258?contestId=165178)

> ## 题目描述
>
> 甲、乙两人同时从 A 地出发要尽快同时赶到 B 地。出发时 A 地有一辆小车，可是这辆小车除了驾驶员外只能带一人。已知甲、乙两人的步行速度一样，且小于车的速度。问：怎样利用小车才能使两人尽快同时到达。
>
> ## 输入格式
>
> 仅一行，三个实数，分别表示 AB 两地的距离 $s$，人的步行速度 $a$，车的速度 $b$。
>
> ## 输出格式
>
> 两人同时到达 B 地需要的最短时间，保留 $6$ 位小数。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
> 120 5 25
> ```
>
> ### 样例输出 #1
>
> ```
> 9.600000
> ```
>
> ## 提示
>
> #### 数据规模与约定
>
> 对于 $100\%$ 的数据，保证 $0 \leq s, a, b \leq 10^9$。

```c
#include <stdio.h>

int main() {
    double s, a, b, x;
    scanf("%lf %lf %lf", &s, &a, &b);
    x = (a + b) * s / (b + 3 * a);
    x = (x / b) + (s - x) / a;
    printf("%.6lf\n", x);
    return 0;
}
```

# [B 笨小猴](https://www.luogu.com.cn/problem/P1125?contestId=165178)

> # [NOIP2008 提高组] 笨小猴
>
> ## 题目描述
>
> 笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！
>
> 这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。
>
> ## 输入格式
>
> 一个单词，其中只可能出现小写字母，并且长度小于 $100$。
>
> ## 输出格式
>
> 共两行，第一行是一个字符串，假设输入的的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；
>
> 第二行是一个整数，如果输入单词是 `Lucky Word`，输出 $\text{maxn}-\text{minn}$ 的值，否则输出 $0$。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
> error
> ```
>
> ### 样例输出 #1
>
> ```
> Lucky Word
> 2
> ```
>
> ## 样例 #2
>
> ### 样例输入 #2
>
> ```
> olympic
> ```
>
> ### 样例输出 #2
>
> ```
> No Answer
> 0
> ```
>

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

// 判断是否为素数
int zhishu(int a) {
    for (int i = 2; i < sqrt(a); i++) {
        if (a % i == 0) {
            return 0;
        }
    }
    return 1;
}

int main() {
    char s[105];
    scanf("%s", s);
    int hash[26];
    memset(hash, 0, sizeof(int) * 26);
    int len = strlen(s);
    int i = 0;
    // 统计字符串中每个字母出现的次数
    for (i = 0; i < len; i++) {
        hash[s[i] - 'a']++;
    }
    int max = 0, min = 105;
    // 找出出现次数的最大值和最小值
    for (i = 0; i < 26; i++) {
        max = fmax(hash[i], max);
        if (hash[i] > 0) {
            min = fmin(hash[i], min);
        }
    }
    int ret = zhishu(max - min);
    if (max - min == 0 || max - min == 1){
        ret = 0;
    }
        if (ret) {
            printf("Lucky Word\n");
            printf("%d\n", max - min);

        } else {
            printf("No Answer\n");
            printf("0\n");
        }
    return 0;
}
```

#  [C 拯救oibh总部](https://www.luogu.com.cn/problem/P1506?contestId=165178)

> ## 题目背景
>
> oibh 总部突然被水淹没了！现在需要你的救援……
>
> ## 题目描述
>
> oibh 被突来的洪水淹没了，还好 oibh 总部有在某些重要的地方起一些围墙。用 `*` 号表示，而一个四面被围墙围住的区域洪水是进不去的。
>
> oibh 总部内部也有许多重要区域，每个重要区域在图中用一个 `0` 表示。
>
> 现在给出 oibh 的围墙建设图，问有多少个没被洪水淹到的重要区域。
>
> ## 输入格式
>
> 第一行为两个正整数 $x,y$。
>
> 接下来 $x$ 行，每行 $y$ 个整数，由 `*` 和 `0` 组成，表示 oibh 总部的建设图。
>
> ## 输出格式
>
> 输出没被水淹没的 oibh 总部的 `0` 的数量。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
>4 5
> 00000
> 00*00
> 0*0*0
> 00*00
> ```
> 
> ### 样例输出 #1
>
> ```
>1
> ```
> 
> ## 样例 #2
>
> ### 样例输入 #2
>
> ```
>5 5
> *****
> *0*0*
> **0**
> *0*0*
> *****
> ```
> 
> ### 样例输出 #2
>
> ```
>5
> ```
> 
> ## 提示
>
> 对于 $100\%$ 的数据，$1 \le x,y \le 500$。

# [D 队列安排 ](https://www.luogu.com.cn/problem/P1160?contestId=165178)

> # 队列安排
>
> ## 题目描述
>
> 一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：
>
> 1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；
>
> 2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；
>
> 3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。
>
> 在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。
>
> ## 输入格式
>
> 第一行一个整数 $N$，表示了有 $N$ 个同学。
>
> 第 $2\sim N$ 行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为 $0$，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。
>
> 第 $N+1$ 行为一个整数 $M$，表示去掉的同学数目。
>
> 接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。
>
> ## 输出格式
>
> 一行，包含最多 $N$ 个空格隔开的整数，表示了队列从左到右所有同学的编号。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
> 4
> 1 0
> 2 1
> 1 0
> 2
> 3
> 3
> ```
>
> ### 样例输出 #1
>
> ```
> 2 4 1
> ```
>
> ## 提示
>
> **【样例解释】**
>
> 将同学 $2$ 插入至同学 $1$ 左边，此时队列为：
>
> `2 1`
>
> 将同学 $3$ 插入至同学 $2$ 右边，此时队列为：
>
> `2 3 1`  
>
> 将同学 $4$ 插入至同学 $1$ 左边，此时队列为：
>
> `2 3 4 1`  
>
> 将同学 $3$ 从队列中移出，此时队列为：
>
> `2 4 1`  
>
> 同学 $3$ 已经不在队列中，忽略最后一条指令
>
> 最终队列：
>
> `2 4 1`  
>
> **【数据范围】**
>
> 对于 $20\%$ 的数据，$1\leq N\leq 10$。
>
> 对于 $40\%$ 的数据，$1\leq N\leq 1000$。
>
> 对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。

```c

```



# [E 句子反转](https://www.luogu.com.cn/problem/B3640?contestId=165178)

> # 句子反转
>
> ## 题目描述
>
> 给定一行句子，每个词之间用空格隔开，要么是全小写英文单词，要么是全大写英文单词，要么是自然数。
>
> 要求将这些单词倒序输出。而且对于每个单词，如果是小写词，应当转为大写；如果是大写词，应当转为小写；如果是自然数，应该倒转输出。
>
> 举一个例子：
> ```plaintext
> we choose TO go 2 the 123 moon
> ```
>
> 程序应当输出：
> ```plaintext
> MOON 321 THE 2 GO to CHOOSE WE
> ```
>
> ## 输入格式
>
> 仅一行，即需要反转的句子。
>
> ## 输出格式
>
> 仅一行，表示程序对句子的处理结果。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
> we choose TO go 2 the 123 moon
> ```
>
> ### 样例输出 #1
>
> ```
> MOON 321 THE 2 GO to CHOOSE WE
> ```
>
> ## 提示
>
> #### 样例解释
>
> 首先应当按单词逆序，即：
> ```plaintext
> moon 123 the 2 go TO choose we
> ```
>
> 小写变大写、大写变小写、倒转自然数之后，得到最终结果：
> ```plaintext
> MOON 321 THE 2 GO to CHOOSE WE
> ```
>
> #### 数据规模与约定
> 对于 $100\%$ 的数据，句子中包含的单词数量不超过 $1000$，每个单词长度不超过 $6$。

本题与力扣[151. 反转字符串中的单词 ](https://leetcode.cn/problems/reverse-words-in-a-string/description/)类似，区别在于不用处理连续多余空格

整体反转一次（单词倒序输出），对每个单词翻转一次（修正单词方向），数字无需翻转（整体翻转时已完成）

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <ctype.h>

void reverse(char *s, int left, int right) {
    //左闭右开
    right--;
    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}

int main() {
    char s[7005];
    gets(s);
    int len = strlen(s);
    reverse(s, 0, len);
    // 大小写字母转换
    for (int i = 0; i < len; i++) {
        if (s[i] <= 'Z' && s[i] >= 'A') {
            s[i] += 32;
        } else if (s[i] <= 'z' && s[i] >= 'a') {
            s[i] -= 32;
        }
    }
    int slow = 0;
    int fast = 0;
    int wordstart = 0;
    for (fast = 0; fast < len; fast++) {
        if (fast != ' ') {
            if (slow != 0) {
                s[slow++] = ' ';
            }
            wordstart = slow;
            while (fast < len && s[fast] != ' ') {
                s[slow++] = s[fast++];
            }
        }
        if (s[wordstart] <= 'z' && s[wordstart] >= 'A') {
            reverse(s, wordstart, slow);
        }
    }
    s[slow]='\0';
    printf("%s", s);
    return 0;
}
```



# [F 明明的随机数](https://www.luogu.com.cn/problem/P1059?contestId=165178)

> # [NOIP2006 普及组] 明明的随机数
>
> ## 题目描述
>
> 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。
>
> ## 输入格式
>
> 输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。
>
> 第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。
>
> ## 输出格式
>
> 输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。
>
> 第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
> 10
> 20 40 32 67 40 20 89 300 400 15
> ```
>
> ### 样例输出 #1
>
> ```
> 8
> 15 20 32 40 67 89 300 400
> ```
>

- `nums[101]`：一个整数数组，用来存储输入的整数，数组大小为101，意味着最多可以输入100个整数。
- `hash[1001]`：一个用于哈希映射的数组，用于统计每个整数的出现次数。

通过遍历 `nums` 数组，并增加 `hash` 数组对应位置的计数，来统计每个整数的出现次数。计算 `hash` 数组中非零元素的数量，并将该数量存储在变量 `count` 中。输出不同整数的数量。再次遍历 `hash` 数组，输出所有出现过的整数（ `hash[i]` 大于0的 `i`）

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>

int main() {
    int n;
    int nums[101];
    int hash[1001];
    memset(hash,0,sizeof(int)*1001);//将哈希表初始化为0。
    int i = 0;
    scanf("%d", &n);
    for (i = 0; i < n; i++) {
        scanf("%d", &nums[i]);
    }
    for (i = 0; i < n; i++) {
        hash[nums[i]]++;
    }
    int count = 0;
    for (i = 0; i < 1001; i++) {
        if (hash[i] > 0) {
            count++;
        }
    }
    printf("%d\n",count);
    for (i = 0; i < 1001; i++) {
        if (hash[i] > 0) {
            printf("%d ", i);
        }
    }
    return 0;
}
```




# [G 小A的糖果](https://www.luogu.com.cn/problem/P3817?contestId=165178)

> # 小A的糖果
>
> ## 题目描述
>
> 小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。
>
> 小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。
>
> ## 输入格式
>
> 输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。
>
> 第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。
>
> ## 输出格式
>
> 输出一行一个整数，代表最少要吃掉的糖果的数量。
>
> ## 样例 #1
>
> ### 样例输入 #1
>
> ```
> 3 3
> 2 2 2
> ```
>
> ### 样例输出 #1
>
> ```
> 1
> ```
>
> ## 样例 #2
>
> ### 样例输入 #2
>
> ```
> 6 1
> 1 6 1 2 0 4
> ```
>
> ### 样例输出 #2
>
> ```
> 11
> ```
>
> ## 样例 #3
>
> ### 样例输入 #3
>
> ```
> 5 9
> 3 1 4 1 5
> ```
>
> ### 样例输出 #3
>
> ```
> 0
> ```
>
> ## 提示
>
> #### 样例输入输出 1 解释
>
> 吃掉第 2 盒中的一个糖果即可。
>
> ---
>
> #### 样例输入输出 2 解释
>
> 第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。
>
> ---
>
> #### 数据规模与约定
>
> - 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
> - 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
> - 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。

```c
#include <stdio.h>

int main() {
    int n, x, a;
    scanf("%d %d", &n, &x);

    long long candies_eaten = 0;//需要被吃的总糖果数量
    int prev_candies = 0;//前一盒剩余的糖果数量
    for (int i = 0; i < n; i++) {
        scanf("%d", &a);
        if (prev_candies + a > x) {//判断前一盒剩余的糖果数量 + 当前和糖果数量不满足最大值
            int eaten = prev_candies + a - x;//计算当前需要被吃的糖果数量
            candies_eaten += eaten;//累加到总数量
            a -= eaten;//计算当前盒吃完后剩余的糖果数量
        }
        prev_candies = a;//更新当前盒为上一盒
    }

    printf("%lld\n", candies_eaten);
    return 0;
}
```

