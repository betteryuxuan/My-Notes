欢迎来到我的博客！

今天，我将和大家分享动态规划这一算法。

#  **动态规划**

## **动态规划的定义**

> 动态规划（Dynamic programming）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。

可以了解到这一算法需要把给定问题分解为子问题，通过子问题的解来得到原问题的解。

## **适用情况**

> 1.**最优子结构性质**。如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。
>
> 2.**无后效性**。即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响。换句话说，子问题的解是相对独立的，它不依赖于包含它的更大问题的解。
>
> 3.**子问题重叠性质**。子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只计算一次，然后将其计算结果保存在一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率，降低了时间复杂度。

## **解题步骤**

1. 确定dp数组以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

下面让我们从几道例题中掌握这种方法吧

# [1. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)

> 假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。
>
> 每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> **示例 1：**
>
> ```
> 输入：n = 2
> 输出：2
> 解释：有两种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶
> 2. 2 阶
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 3
> 输出：3
> 解释：有三种方法可以爬到楼顶。
> 1. 1 阶 + 1 阶 + 1 阶
> 2. 1 阶 + 2 阶
> 3. 2 阶 + 1 阶
> ```
>
>  
>
> **提示：**
>
> - `1 <= n <= 45`

1. **确定dp数组以及下标的含义**

`dp[i]`表示爬到第`i`层楼梯的不同方式的数量。

2. **确定递推公式**

每次只能爬一层或者两层楼梯，例如我们到最后一层台阶只有两种情况，要么是从`n-1`爬1层，要么是从`n-2`爬2层到达第n层，即到达第i层的方式只能从第i-1层爬一步或者从第i-2层爬两步而来。

所以递推公式为：`dp[i] = dp[i-1] + dp[i-2]`。

3. **dp数组如何初始化**

`dp[0]`表示的是到达第0层有多少种方式，所以`dp[0] = 0`

到达第1层的方式只有一种，所以`dp[1] = 1`

`dp[2] = 2`，显而易见，到达第2层的方式有两种，此时不满足递推公式，因此我们将循环从`i = 3`开始

或者我们也可以定义`dp[0]=1`，此时就不需要单独定义`dp[2] = 2`，循环从`i = 2`开始。

4. **遍历顺序** 

   从前往后遍历，因为每一步的计算都需要用到前面的结果。

5. **举例推导dp数组**

我们可以把dp数组打印出来，来看看那一步有问题

```c
dp[3] = dp[2] + dp[1] = 2 + 1 = 3 
dp[4] = dp[3] + dp[2] = 3 + 2 = 5
...
dp[i] = dp[i - 1] + dp[i - 2] 
```

下面给出代码

```c
int climbStairs(int n) {
    // 如果楼梯层数小于等于2，直接返回 n
    if(n <= 2){
        return n;
    }
    int* dp = (int*)malloc(sizeof(int)*(n+1));//开辟n+1，因为我们要返回dp[n]
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    for(int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```





# [2. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

>给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。
>
>你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。
>
>请你计算并返回达到楼梯顶部的最低花费。
>
>**示例 1：**
>
>```
>输入：cost = [10,15,20]
>输出：15
>解释：你将从下标为 1 的台阶开始。
>- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
>总花费为 15 。
>```
>
>**示例 2：**
>
>```
>输入：cost = [1,100,1,1,1,100,1,1,100,1]
>输出：6
>解释：你将从下标为 0 的台阶开始。
>- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
>- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
>- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
>- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
>- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
>- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
>总花费为 6 。
>```
>
>**提示：**
>
>- `2 <= cost.length <= 1000`
>- `0 <= cost[i] <= 999`



1. **确定dp数组以及下标的含义**

与爬楼梯相似，不过此时我们要算上花费费用，我们可以定义`dp[i]`为到达`i`层台阶的最低花费，

2. **确定递推公式**

可以得到`dp[i]=fmin(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])`

该递推公式表示到达第`i`层共有两种方式：一种为到达`dp[i-1]`所花费用并爬一层支付`cost[i-1]`到达第`i`层，另一种为到达`i-2`层`dp[i-2]`所花费用并爬两层支付`cost[i-2]`到达第`i`层。

3. **dp数组如何初始化**

题目中称`你可以选择从下标为 0 或下标为 1的台阶开始爬楼梯`

因此`dp[0]`和`dp[1]`的最小花费为0

4. **确定遍历顺序**

从前往后遍历，每一步都需要前面的值

5. **举例推导dp数组**

`cost = [10,15,20] costSize = 3`我们要爬到第三层台阶

`dp[2] = fmin(dp[1]+cost[1],dp[0]+cost[0]) = 10`

`dp[3] = fmin(dp[2]+cost[2],dp[1]+cost[1]) = 15`



下面给出代码

```c
int minCostClimbingStairs(int* cost, int costSize) {
    int* dp = (int*)malloc(sizeof(int)*(costSize+1));
    dp[0] = 0;
    dp[1] = 0;
    int i = 0;
    for(i = 2; i <= costSize; i++) {
        dp[i] = fmin(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[costSize];
}
```





# [3. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

> 一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
>
> 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
>
> 网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。
>
>  **示例 1：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)
>
> ```
> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
> 输出：2
> 解释：3x3 网格的正中间有一个障碍物。
> 从左上角到右下角一共有 2 条不同的路径：
> 1. 向右 -> 向右 -> 向下 -> 向下
> 2. 向下 -> 向下 -> 向右 -> 向右
> ```
>
> **示例 2：**
>
> ![img](https://assets.leetcode.com/uploads/2020/11/04/robot2.jpg)
>
> ```
> 输入：obstacleGrid = [[0,1],[0,0]]
> 输出：1
> ```
>
>  **提示：**
>
> - `m == obstacleGrid.length`
> - `n == obstacleGrid[i].length`
> - `1 <= m, n <= 100`
> - `obstacleGrid[i][j]` 为 `0` 或 `1`



1. **确定dp数组以及下标的含义**

`dp`数组为二维数组，表示到达`dp[i][j]`共有多少种不同的路径

2. **确定递推公式**

`机器人每次只能向下或者向右移动一步`

所以到达`[i][j]`分别可以从`[i-1][j]`和`[i][j-1]`两种方式到达，等于上方和左方路径数之和

因此`dp[i][j] = [i - 1][j] + [i][j - 1]`

3. **dp数组如何初始化**

当没有障碍时，到达第一行或第一列的任意位置只有一种方式，要么一直向右或向下。

当有障碍时，那么对于第一行或第一列来说，到达障碍后的位置的方式为0种，因此我们初始化二维数组为0，到达障碍前赋值为1，那么障碍后为0。

4. **确定遍历顺序**

从前向后遍历，并且从第二行第二列开始。

5. **举例推导dp数组**

下面给出代码

```c
int uniquePathsWithObstacles(int** obstacleGrid, int obstacleGridSize, int* obstacleGridColSize) {
    int i = 0, j = 0;
    //二维dp数组的初始化
    int** dp = (int**)malloc(sizeof(int*)*obstacleGridSize);
    for(i = 0; i < obstacleGridSize; i++) {
        dp[i] = (int*)malloc(sizeof(int)*(*obstacleGridColSize));
        memset(dp[i], 0, sizeof(int)*(*obstacleGridColSize));
    }
    // 初始化第一列，遇到障碍物停止
    for(i = 0; i < obstacleGridSize && obstacleGrid[i][0] == 0; i++) {
        dp[i][0] = 1;
    } 
    // 初始化第一行，遇到障碍物停止
    for(j = 0; j < (*obstacleGridColSize) && obstacleGrid[0][j] == 0; j++) {
        dp[0][j] = 1;
    }
    //obstacleGrid[i][j] == 0表示遇到障碍物，不计算，dp[i][j]==0
    for(i = 1; i < obstacleGridSize; i++) {
        for(j = 1; j < (*obstacleGridColSize); j++) {
            if(obstacleGrid[i][j] == 0) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
    }
    
    int ret = dp[obstacleGridSize - 1][(*obstacleGridColSize) - 1];
    
    for(i = 0; i < obstacleGridSize; i++){
        free(dp[i]);
    }
    free(dp);
    return ret; 
}
```





#  [4 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
> 返回 *你能获得的 **最大** 利润* 。
>
>  **示例 1：**
>
> ```
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>      总利润为 4 + 3 = 7 。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>      总利润为 4 。
> ```
>
> **示例 3：**
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
> ```
>
>  **提示：**
>
> - `1 <= prices.length <= 3 * 104`
> - `0 <= prices[i] <= 104`

1. **确定dp数组以及下标的含义**

`dp[i]`表示第i天

`dp[i][0]`表示持有股票所得现金

`dp[i][1]`表示不持有股票所得现金

2. **确定递推公式**

`dp[i][0] = fmax(dp[i - 1][0], dp[i - 1][1] - prices[i])`

第i天持有股票：i-1天就持有股票；i-1天不持有股票，第i天购入。

`dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i])`

第i天不持有股票：i-1天就不持有股票；i-1天持有股票，第i天售出。

3. **dp数组如何初始化**

`dp[0][0] = -prices[0]` ：第0天持有股票，即第0天买入

`dp[0][1] = 0`

4. **确定遍历顺序**

从前向后遍历

5. **举例推导dp数组**

下面给出代码

```c
int maxProfit(int* prices, int pricesSize) {
    int i = 0;
    int** dp = (int**)malloc(sizeof(int*)*pricesSize);  
    for(i = 0; i < pricesSize; i++){
        dp[i] = (int*)malloc(sizeof(int)*2);
        memset(dp[i], 0, sizeof(int)*2);
    }
    
    dp[0][0] = -prices[0];
    dp[0][1] = 0;
    
    for(i = 1; i < pricesSize; i++){
        dp[i][0] = fmax(dp[i - 1][0], dp[i - 1][1] - prices[i]);
        dp[i][1] = fmax(dp[i - 1][1], dp[i - 1][0] + prices[i]);
    }
    //返回最后一天不持有股票的最大利润
    return dp[pricesSize - 1][1];
}
```

#  [5. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/)

>给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>返回你能获得的 **最大** 利润 。
>
>**示例 1：**
>
>```
>输入：prices = [7,1,5,3,6,4]
>输出：7
>解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>     总利润为 4 + 3 = 7 。
>```
>
>**示例 2：**
>
>```
>输入：prices = [1,2,3,4,5]
>输出：4
>解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>     总利润为 4 。
>```
>
>**示例 3：**
>
>```
>输入：prices = [7,6,4,3,1]
>输出：0
>解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
>```
>
> **提示：**
>
>- `1 <= prices.length <= 3 * 104`
>- `0 <= pric`

1. **确定 dp 数组以及下标的含义：**

   `dp[i][j]` 表示第 i 天状态j所剩最大现金。

   `dp[i][0]` 表示第 i 天 <u>没有操作</u> 所剩最大现金。

   `dp[i][1]` 表示 <u>第一次持有</u> 股票所剩最大现金。

   `dp[i][2]` 表示 <u>第一次不持有</u>股票所剩最大现金。

   `dp[i][3]` 表示 <u>第二次持有</u> 股票所剩最大现金。

   `dp[i][4]` 表示 <u>第二次不持有</u> 股票所剩最大现金。

2. **确定递推公式：**

   `dp[i][0] = 0`
   `dp[i][1] = fmax(dp[i - 1][1], dp[i][0] - prices[i])`

   第一次持有:前一天持有；前一天不持有，今天买入
   `dp[i][2] = fmax(dp[i - 1][2], dp[i - 1][1] + prices[i])`

   第一次不持有:前一天不持有；前一天持有今天卖出
   `dp[i][3] = fmax(dp[i - 1][3], dp[i - 1][2] - prices[i])`

   第二次持有:前一天第二次持有；前一天第一次不持有今天卖出
   `dp[i][4] = fmax(dp[i - 1][4], dp[i - 1][3] + prices[i])`

   第二次不持有:前一天第二次不持有；前一天第二层持有，今天卖出

3. **`dp` 数组如何初始化：**

   `dp[0][0] = 0`：第0天没有操作

   `dp[0][1] = -prices[0]`：第0天买入
   `dp[0][2] = 0`：第0天买入卖出
   `dp[0][3] = -prices[0]`：第0天买入卖出第一支股票，并买入第二支股票
   `dp[0][4] = 0`：第0天进行两次买入卖出

4. **确定遍历顺序：**

   - 从前向后遍历。

5. **举例推导 `dp` 数组：**

下面给出代码

```c
int maxProfit(int* prices, int pricesSize) {
    int** dp = (int**)malloc(sizeof(int*)*pricesSize);
    int i = 0;
    for(i = 0; i < pricesSize; i++){
        dp[i] = (int*)malloc(sizeof(int)*5);
    }
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    dp[0][2] = 0;
    dp[0][3] = -prices[0];
    dp[0][4] = 0;
    for(i = 1; i < pricesSize; i++){
        dp[i][0] = 0;
        dp[i][1] = fmax(dp[i - 1][1], dp[i][0] - prices[i]);//第一次持有
        dp[i][2] = fmax(dp[i - 1][2], dp[i - 1][1] + prices[i]);//第一次不持有
        dp[i][3] = fmax(dp[i - 1][3], dp[i - 1][2] - prices[i]);//第二次持有
        dp[i][4] = fmax(dp[i - 1][4], dp[i - 1][3] + prices[i]);//第二次不持有
    }
    return dp[pricesSize-1][4];
}
```



> 参考：
>
> 1.[动态规划 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/动态规划#)
>
> 2.[代码随想录 (programmercarl.com)](https://programmercarl.com/动态规划理论基础.html#什么是动态规划)



---



感谢您的阅读