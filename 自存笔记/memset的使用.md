

[memset函数详解 - handsomecui - 博客园 (cnblogs.com)](https://www.cnblogs.com/handsomecui/p/4723949.html)

**首先要知道memset函数是对字节为单位进行赋值的；**

`void *memset(void *s, int ch, size_t n);`

函数解释：将s中前n个字节 （typedef unsigned int size_t ）用 ch 替换并返回 s 。

其实这里面的ch就是ascii为ch的字符；

将s所指向的某一块内存中的前n个字节的内容全部设置为ch指定的[ASCII](http://baike.baidu.com/view/15482.htm)值

---



memset：作用是在一段内存块中填充某个给定的值，它是对较大的[结构体](http://baike.baidu.com/view/204974.htm)或[数组](http://baike.baidu.com/view/209670.htm)进行清零操作的一种最快方法[1] 

如果用memset(a,1,20);（实际上与memset(a,1,5*sizeof(int))结果是一样的）就是对a指向的内存的20个字节进行赋值，每个都用ASCⅡ为1的字符去填充，转为二进制后，1就是00000001，占一个字节。一个INT元素是4字节，合一起是0000 0001,0000 0001,0000 0001,0000 0001，转化成十六进制就是0x01010101，就等于16843009，就完成了对一个INT元素的赋值了。

---



清零是memset(a,0,sizeof(a));

初始化为无穷大为memset(a,0x3f,sizeof(0x3f));

下面谈谈无穷大的用法；

0x3f3f3f3f的十进制是1061109567，也就是10^9 级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。

![0x3f](https://raw.githubusercontent.com/betteryuxuan/Image/main/0x3f.png)

另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。

最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))这样的代码来实现（方便而高效），但是当我们想将某个数组全部赋值为无穷大时（例如解决图论问题时邻接矩阵的初始化），就不能使用memset函数而得自己写循环了（写这些不重要的代码真的很痛苦），我们知道这是因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0，现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。

所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择。

因为char是1字节，memset是按照字节赋值的，相当于把每个字节都设为那个数，所以char型的数组可赋任意值，int是4个字节，当memset(,1,sizeof()); 1相当于ASSCII码的1，1转为二进制00000001，当做一字节，一字节8位，int为4字节，所以初始化完每个数为00000001000000010000000100000001 = 16843009；

初始化最大值的方法：

如果你想初始最大化，第一位为符号位，不能为1，剩下全是1，也就是7个1,1111111化为

十六进制正好为0x7f，所以memset(,0x7f,sizeof());就可以了