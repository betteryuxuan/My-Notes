# 1. JVM

Java虚拟机（JVM，Java Virtual Machine）

## 1.1 职责

本质是一个程序，职责如下

1. **加载字节码**：JVM加载编译后的Java字节码文件（.class文件），并将其解释或编译为机器码以供执行。
2. **执行代码**：JVM解释执行字节码或使用即时编译器（JIT）将字节码编译为本地机器码执行。

## 1.2 功能

1. **内存管理**：JVM负责管理程序运行时所需的内存，包括堆内存和栈内存的分配和回收。
2. **垃圾回收**：JVM自动进行垃圾回收，回收不再使用的对象，避免内存泄漏。
3. **即时编译**：对热点代码进行优化， 提升执行效率。 

**即时编译（Just-In-Time)**：

>  用于将程序源代码或中间代码（如Java字节码）在运行时即时编译成机器码

原理：

1. **热点代码识别**：JIT编译器会监视程序的执行情况，识别出频繁执行的热点代码段，即被频繁调用的方法或循环体。
2. **即时编译**：一旦识别出热点代码，JIT编译器会将其编译成本地机器码，存储在代码缓存中，以备后续调用。
3. **本地机器码执行**：一旦热点代码被编译成本地机器码，后续执行时就<u>不再需要解释执行字节码</u>，而是直接执行编译后的本地机器码，从而提高了程序的执行效率。

![image-20240605215332730](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240605215332730.png)

# 2. 内存区域

![image-20250329154915538](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20250329154915538.png)

## 2.1 程序计数器

### 概念

- **定义**：程序计数器（PC寄存器）是JVM内存模型中的一部分，用于记录当前线程正在执行的字节码指令地址（或行号）。
- JVM解释器通过程序计数器读取下一条需要执行的字节码指令。

###  作用

1. **记录执行位置**
   - 执行Java方法时，保存当前线程**正在执行的字节码指令地址**。
   - 执行Native方法（如C/C++代码）时，程序计数器值为`undefined`（不同JVM实现可能不同）。
2. **支持多线程切换**
   - CPU时间片轮转时，线程可能被挂起，程序计数器确保线程恢复后能继续执行正确的指令。

### 特点

**1. 线程私有**

> 作用：避免多线程竞争，确保线程独立性。

**内存隔离**：程序计数器属于线程私有内存

**独立性**：每个线程在创建时，会拥有自己的程序计数器，用于记录当前线程正在执行的字节码指令地址。这意味着不同线程之间的执行进度互不干扰，一个线程的跳转或异常不会影响到其他线程的执行过程。

**多线程并发：**
在多线程环境中，线程私有内存（包括程序计数器）使得每个线程的运行状态完全独立，避免了资源竞争和同步问题，降低了死锁、竞态条件等并发编程的风险。

**设计简化：**
 线程私有的设计简化了 JVM 对执行状态管理的复杂度，每个线程只需关注自己内部的执行流程，无需担心外部干扰。

**2. 无OOM异常**

> JVM规范未定义程序计数器的OOM（OutOfMemoryError）场景。

因为它不占用堆或方法区，仅存储当前指令的地址。

- **3. 占用较小内存**：仅保存一个指令地址（或Native方法的`undefined`），内存消耗可忽略。
- **4. 无垃圾回收**：不涉及对象存储，无需GC管理。

### 与其他内存区域对比

|      区域      | 线程共享/私有 | 是否可能OOM |           存储内容           |
| :------------: | :-----------: | :---------: | :--------------------------: |
| **程序计数器** |   线程私有    |      ❌      |         当前指令地址         |
|  **虚拟机栈**  |   线程私有    | ✔️（栈溢出） | 栈帧（局部变量、操作数栈等） |
|     **堆**     |   线程共享    |      ✔️      |           对象实例           |
|   **方法区**   |   线程共享    |      ✔️      |   类信息、常量、静态变量等   |

### **常见问题**

1. **Native方法为何PC为undefined？**
   Native方法通过本地库（如JNI）执行，其指令地址由操作系统或本地库管理，不由JVM控制。

2. **程序计数器是否可能为null？**

   - Java方法执行时：始终指向有效指令地址。
   - Native方法执行时：值为`undefined`，但不为null。

3. **为什么程序计数器是线程私有？**
   多线程并发执行时，各线程可能处于不同方法的不同指令位置，私有化确保线程独立性。

5. |     **特性**     |        **JVM程序计数器**        | **物理CPU程序计数器（PC）** |
   | :--------------: | :-----------------------------: | :-------------------------: |
   |   **实现方式**   |    逻辑概念（由JVM软件实现）    |   物理寄存器（硬件实现）    |
   |   **存储内容**   | 字节码指令地址（或`undefined`） |     机器指令的内存地址      |
   |   **作用范围**   |            线程私有             |         CPU核心私有         |
   |   **内存管理**   |   不占用堆/栈，无内存分配问题   |  物理寄存器，直接由CPU管理  |
   | **本地方法支持** |  执行本地方法时值为`undefined`  |  始终指向当前机器指令地址   |

### 工作流程

```java
0: iload_1     // 加载局部变量1到操作数栈
1: iload_2     // 加载局部变量2到操作数栈
2: iadd        // 执行加法
3: istore_3    // 将结果存储到局部变量3
```

- 当线程执行到`iadd`（地址2）时，程序计数器值为`2`。
- 执行完`iadd`后，程序计数器自动更新为`3`，指向`istore_3`。

## 2.2 虚拟机栈

（Java Virtual Machine Stack）

### 概念
• **定义**：虚拟机栈是线程私有的内存区域，用于存储方法的调用和执行信息。每个方法调用对应一个**栈帧**（Stack Frame）。
• **生命周期**：**与线程相同**，线程启动时创建，线程结束时销毁。
• **核心功能**：保存方法的局部变量、操作数栈、动态链接、方法返回地址等。

### 栈帧

> 每个方法运行时需要的内存

每个栈帧包含以下组件：
1. **局部变量表
   • 存储方法的**参数**和**局部变量**（包括基本类型和对象引用）。
   • 以**变量槽**（Slot）为最小单位（32位类型占1个Slot，64位如`long`/`double`占2个Slot）。

2. **操作数栈
   • 用于执行字节码指令的**临时数据存储区**（如算术运算、方法参数传递）。
   • 类似CPU的寄存器，但通过“栈”结构操作（压入、弹出）。

3. **动态链接
   • 指向**运行时常量池**的引用，用于支持方法调用时的动态绑定（如多态）。

4. **方法返回地址**
   • 记录方法执行完成后需要返回的指令位置（正常返回或异常退出）。

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20250329120305237.png" alt="image-20250329120305237" style="zoom: 50%;" />

### 作用
1. **方法调用与执行** 
   • 每个方法从调用到完成对应一个栈帧的入栈（`invoke`指令）到出栈（`return`指令）。
   
2. **存储方法运行数据** 
   • 局部变量表保存方法内部状态，操作数栈支持指令计算。

3. **异常处理** 
   • 栈帧中存储的异常表（Exception Table）用于定位`try-catch`的跳转地址。

### 异常与错误
* **栈内存溢出（栈帧过多或栈帧过大）**：**StackOverflowError** 
    • **触发条件**：线程请求的栈深度超过JVM允许的最大深度（如无限递归调用）。
    • **默认栈大小**：不同JVM实现不同，HotSpot默认为1MB（可通过`-Xss`参数调整，如`-Xss256k`）。

* **OutOfMemoryError** 
    • **触发条件**：如果Java虚拟机栈容量可以动态扩展，栈扩展时无法申请到足够内存（如多线程场景下系统内存耗尽）。

### 线程运行诊断

发现 CPU 占用过高时，如何定位问题线程和代码行？

1. **使用 top 命令定位问题进程**
    通过 top 命令查看系统中哪个进程的 CPU 占用率最高，从而确定是哪个 Java 进程存在问题。

2. **使用 ps 命令进一步查找具体线程**
    执行类似如下命令：

   ```bash
   ps -H -eo pid,tid,%cpu | grep <进程ID>
   ```

   这条命令会列出该进程下各个线程的 CPU 使用情况，通过观察哪条线程（tid）占用 CPU 过高，就可以确定具体问题线程。

3. **使用 jstack 命令生成线程 dump**

   ```bash
   jstack <进程ID>
   ```

   得到整个进程的线程 dump，找到刚才 ps 命令中识别出的线程 ID 对应的线程堆栈信息。

4. **定位到具体源码行号**
    根据线程堆栈中显示的信息，可以追踪到具体的方法调用栈，进一步确定问题代码所在的源码行。

### 示例场景

**方法调用与栈帧变化**

```java
public class StackDemo {
    public static void main(String[] args) {
        int a = 1;
        int b = 2;
        int result = add(a, b);  // 调用add方法，栈帧入栈
        System.out.println(result);
    }

    static int add(int x, int y) {
        return x + y;            // 方法返回，栈帧出栈
    }
}
```
• **栈帧变化**：  
  `main`方法栈帧 → 调用`add`方法时新栈帧入栈 → `add`返回后栈帧出栈。

### 常见问题
**1. 垃圾回收是否涉及栈内存？**

> 垃圾回收主要针对的是**堆内存**。在Java中，对象实例通常分配在堆内存上，垃圾回收器会负责回收不再被引用的堆内存对象。而**栈内存**主要用于存储方法调用的栈帧，包括局部变量、方法参数等，其生命周期由方法调用和返回自动管理，因此不需要垃圾回收机制介入。

**2. 栈内存分配越大越好吗？**

> 栈内存并非越大越好。
>
> * **优点**：较大的栈内存可以允许更深的递归调用和更复杂的调用栈，在某些算法和业务场景下是必要的。
> * **缺点**：如果栈内存分配过大，会导致每个线程占用更多内存，容易耗尽总内存资源。

**3. 方法内的局部变量是否线程安全？**

> **局部变量通常是线程安全的。**
>
> * **原因**：方法内的局部变量是在当前线程的栈上分配的，每个线程都有独立的栈空间，变量之间互不干扰，因此其存取是线程安全的。
> * **注意点**：如果<u>局部变量存储的是可变对象的引用，并且这个对象被传递到其他线程中使用</u>，那么该对象的线程安全性就需要额外关注和处理。例如，局部变量引用的集合对象如果被多个线程共享修改，则需要进行同步控制。

|            场景            | 线程安全？ |                   原因                   |
| :------------------------: | :--------: | :--------------------------------------: |
| 基本类型局部变量（未逃逸） |   ✅ 安全   |            变量在线程私有栈中            |
| 对象引用局部变量（未逃逸） |   ✅ 安全   |      对象未被共享，作用域限于方法内      |
|   对象引用逃离方法作用域   |  ❌ 不安全  | 对象可能被多线程共享，需同步或不可变设计 |

## 2.3 本地方法栈

本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务。

###  概念

- **作用**：为 JVM 执行 **Native 方法**（非 Java 代码实现的方法，如 C/C++ 编写的 JNI 方法）提供内存空间。
- **归属**：线程私有，每个线程在创建时都会分配独立的本地方法栈。
- 异常：
  - `StackOverflowError`：栈深度超过 JVM 限制时抛出（如递归调用过深）。
  - `OutOfMemoryError`：栈扩展失败时抛出（如内存不足）。

### 与虚拟机栈区别

|     **特性**     |             **本地方法栈**             |    **虚拟机栈（Java 栈）**     |
| :--------------: | :------------------------------------: | :----------------------------: |
|   **服务对象**   |       Native 方法（如 JNI 方法）       |      Java 方法（字节码）       |
|   **实现规范**   |        可选，依赖具体 JVM 实现         |     强制要求，JVM 规范定义     |
|   **溢出风险**   |  较少见（Native 方法通常由 JVM 管理）  | 常见（如无限递归、大对象分配） |
| **HotSpot 实现** | 与虚拟机栈合并（通过参数 `-Xss` 设置） |              同左              |

### 实现细节

> 《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。

- **栈合并**：HotSpot 将虚拟机栈与本地方法栈合并，通过一个统一的栈结构管理。
- Native 方法调用流程：
  1. Java 代码调用 `native` 方法。
  2. JVM 通过动态链接库（如 `.dll` 或 `.so`）加载 Native 方法。
  3. 创建本地方法栈帧，执行 Native 代码。
  4. 返回结果并销毁栈帧。

## 2.4 堆

### 概念
**作用**：JVM 中**最大**的内存区域，用于存储**所有对象实例**和**数组**（通过 `new` 关键字创建的对象）。
**归属**：线程共享，所有线程均可访问堆中的对象。
**生命周期**：对象在堆中分配内存，由垃圾回收器（GC）自动回收（无显式释放）。
**异常**：
 `OutOfMemoryError`：堆内存不足且无法扩展时抛出（如内存泄漏或对象过多）。

### 堆与其他内存区域的关系
**栈**：栈帧中存储对象的引用（指向堆中的对象实例）。 
**方法区**：存储类信息、静态变量，部分数据可能位于堆的元空间（JDK8+）。  

## 2.5 方法区

