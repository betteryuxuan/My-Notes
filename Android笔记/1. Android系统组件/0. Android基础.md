# 一、工程目录结构

项目，模块

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240616193330613.png" alt="image-20240616193330613" style="zoom:80%;" />

该项目下面有两个分类：一个是app（代表app模块）；另一个是Gradle Scripts。

## 1.1 app模块

`app`下面有3个子目录：

**（1）manifests子目录**，下面只有一个XML文件，即`AndroidManifest.xml`，它是App的运行配置文件。 

**（2）java子目录**，下面有3个`com.example.myapp`包，其中第一个包存放当前模块的java源代码，后面两个包存放测试用的java代码。

**（3）res子目录**，存放当前模块的资源文件。

`res`下面又有4个子目录：

* `drawable`目录存放图形描述文件与图片文件
* `layout`日录存放App页面的布局文件
* `mipmap`日录存放App的启动图标
* `values`目录存放一些常量定义文件，例如字符串常量`strings.xml`、像素常量`dimens.xml`、颜色常量`colors.xml`、样式风格定义`styles.xml`等。

## 1.2 gradle模块

> Gradle是一个项目自动化构建工具，帮我们做了依赖、打包、部署、发布、各种渠道的差异管理等工作。

Gradle scripts下面主要是工程的编译配置文件，主要有:
（1）`build.gradle`，该文件分为项目级与模块级两种，用于描述App工程的编译规则。
（2）`proguard-rues.pro`，该文件用于描述java代码的混淆规则。
（3）`gradle.properties`，该文件用于配置编译工程的命令行参数，一般无须改动。
（4）`settings.gradle`，该文件配置了需要编译哪些模块。初始内容为include':app'，表示只编译app模块。
（5）`local.properties`，项目的本地配置文件，它在工程编译时自动生成，用于描述开发者电脑的环境配置，包括SDK的本地路径、NDK的本地路径等。

## 1.3 编译配置文件

`build.gradle`

项目级别的`build.gradle`指定了当前项目的总体编译规则
模块级别的`build.gradle`对应于具体模块，每个模块都有自己的`build.gradle`，它指定
了当前模块的详细编译规则。

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240616195026321.png" alt="image-20240616195026321" style="zoom: 80%;" />

```kotlin
plugins {
    alias(libs.plugins.android.application)
}

android {
    namespace = "com.example.activitytest"
    // 指定编译用的SDK版本
    compileSdk = 34

    defaultConfig {
        //指定该模块的应用编号，即App包名
        applicationId = "com.example.activitytest"
        //指定App适合运行的最小SDK版本号
        minSdk = 28
        //指定目标设备的SDK版本号
        targetSdk = 34
        //指定App的应用版本号
        versionCode = 1
        //指定App的应用版本名称
        versionName = "1.0"

        //单元测试
        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            //是否开启代码混淆
            isMinifyEnabled = false
            //指定代码混淆配置文件
            proguardFiles(getDefaultProguardFile("proguard-android-optimize.txt"), "proguard-rules.pro")
        }
    }
    // 配置Java编译选项
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

//依赖项
dependencies {
    // 基础库
    implementation(libs.appcompat)
    implementation(libs.material)
    implementation(libs.activity)
    // 单元测试库
    testImplementation(libs.junit)
    // Android测试库
    androidTestImplementation(libs.ext.junit)
    androidTestImplementation(libs.espresso.core)
}
```

## 1.4 清单文件

每个应用的根目录中都必须包含一个`AndroidManifest.xml`，并且文件名必须一模一样。

这个文件中包含了APP的配置信息，系统需要根据里面的内容运行APP的代码，显示界面

```java
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <application
        //是否允许应用备份
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        //显示图标  
        android:icon="@mipmap/ic_launcher"
        //显示名称
        android:label="@string/app_name"
        //指定圆角图标
        android:roundIcon="@mipmap/ic_launcher_round"
        //是否支持阿拉伯语/波斯语这种从右往左的文字排列顺序
        android:supportsRtl="true"
        //android:theme，指定App的显示风格
        android:theme="@style/Theme.ActivityTest"
        tools:targetApi="31">
            
        //activity节点指定了该App拥有的活动页面信息，其中拥有android.intent.action.MAIN的activity说明他是入口页面
        <activity
            android:name=".FirstActivity"
            android:exported="true">
            //配置默认主页，必须同时配置这两种过滤规则
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

    </application>

</manifest>
```

> Activity 是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务

# 二、界面显示与逻辑处理

> 界面设计与代码逻辑分开

## 2.1 好处

使用 XML 文件描述 APP 界面，可以方便地在 Android Studio 上预览界面效果。

一个界面布局可以被多处代码复用，反过来，一个Java 代码也可能适配多个界面布局。

## 2.2 代码示例

`src`下`layout`的`activity_main.xml`代码：

```xml
<?xml version="1.0" encoding="utf-8" ?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:gravity="center"
    android:orientation="vertical">

    <TextView
        android:id="@+id/tv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:text="Hello Xuan" />

</LinearLayout>
```

`MainActivity`代码：

```java
package com.example.helloxuan;

import android.os.Bundle;
import android.widget.TextView;

import androidx.appcompat.app.AppCompatActivity;

public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        TextView tv = findViewById(R.id.tv);
        tv.setText("你好 轩");
    }
}
```

## 2.3 Activity 创建与跳转

创建新的 App 页面过程包括三个步骤：

1. 在`layout`目录下创建`XML`文件
2. 创建与`XML`文件对应的 Java 代码
3. 在`AndroidManifest.xml`中注册页面配置

```java
public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 找到布局文件中的 TextView，并设置显示的文本内容为 "你好 xuan!!!!"
        TextView tv = findViewById(R.id.tv);
        tv.setText("你好 xuan!!!!");

        // 找到布局文件中的 Button，并设置点击事件监听器
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 当按钮被点击时，创建一个意图（Intent），用于启动 MainActivity2
                Intent intent = new Intent();
                intent.setClass(MainActivity.this, MainActivity2.class);
                startActivity(intent); // 启动 MainActivity2
            }
        });
    }
}
```

```java
public class MainActivity2 extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main2);
    }
}
```

## 2.4 Intent

### 2.4.1 显式和隐式Intent

- **显式Intent**：用于在应用内部启动组件（如Activity、Service、BroadcastReceiver）。显式Intent会指定要启动的组件的类名，例如：
  ```java
  Intent explicitIntent = new Intent(this, TargetActivity.class);
  startActivity(explicitIntent);
  ```
- **隐式Intent**：用于在不指定组件名称的情况下启动组件，而是通过指定动作（Action）、数据（Data）和类型（Type）等信息，让系统去匹配合适的组件。例如，启动一个浏览器来打开指定网址：
  ```java
  Intent implicitIntent = new Intent(Intent.ACTION_VIEW, Uri.parse("https://www.baidu.com"));
  startActivity(implicitIntent);
  ```

**区别**：

- **目的**：显式Intent用于精确指定要启动的组件，通常在应用内部使用；隐式Intent用于请求系统启动能够处理指定动作或数据类型的任何组件。
- **使用方式**：显式Intent直接指定组件类名，而隐式Intent通过设置动作、数据等信息间接指定要启动的组件，系统会根据匹配规则找到合适的组件处理请求。

### 2.4.2 活动间传递数据

1. **向下一个活动传递数据**

有两个活动：`MainActivity` 和 `SecondActivity`，要从 `MainActivity` 向 `SecondActivity` 传递数据。

在 `MainActivity` 中：

1. 创建一个 `Intent` 对象，并使用 `putExtra` 方法添加要传递的数据。
2. 使用 `startActivity` 方法启动 `SecondActivity`。

```java
        Button button3 = findViewById(R.id.button3);
        button3.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String data  = "祝你开心永远";
                Intent intent = new Intent(MainActivity.this, SecondActivity.class);
                intent.putExtra("extra_data",data);
                startActivity(intent);
            }
        });
```

在 `SecondActivity` 中：

1. 在 `onCreate` 方法中获取传递过来的数据。

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_second);
    
    // 获取传递的数据
    Intent intent = getIntent();
    String value = intent.getStringExtra("key");
}
```

2. **返回数据给上一个活动**

在 Android 中，如果我们需要从一个活动返回数据给上一个活动，可以使用 `startActivityForResult` 方法启动目标活动，并在目标活动中设置结果数据。

在 `MainActivity` 中：

1. 使用 `startActivityForResult` 方法启动 `SecondActivity`。
2. 重写 `onActivityResult` 方法来接收返回的数据。

```java
// 启动 SecondActivity 并请求返回结果
Intent intent = new Intent(MainActivity.this, SecondActivity.class);
startActivityForResult(intent, 1);

// 重写 onActivityResult 方法来接收返回的数据
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (requestCode == 1 && resultCode == RESULT_OK) {
        // 从返回的 Intent 中获取数据
        String result = data.getStringExtra("result_key");
        // 处理返回的数据
    }
}
```

在 `SecondActivity` 中：

1. 创建一个 `Intent` 对象，并使用 `putExtra` 方法添加要返回的数据。
2. 使用 `setResult` 方法设置结果，并传入包含数据的 `Intent`。
3. 调用 `finish` 方法关闭当前活动。

```java
// 创建一个 Intent 对象并添加要返回的数据
Intent returnIntent = new Intent();
returnIntent.putExtra("result_key", "result_value");

// 设置结果并传入包含数据的 Intent
setResult(RESULT_OK, returnIntent);

// 关闭当前活动
finish();
```

# 三、简单控件

## 3.1 文本显示

### 3.1.1 设置宽高

1. 在布局文件中设置

`match_parent`：控件会占满父布局的全部空间。

`wrap_content`：控件会根据其内容大小自动调整。

精确值：如 `200dp`，指定具体的宽度或高度。

```xml
<TextView
    android:id="@+id/myTextView"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:text="Hello, World!"
    android:gravity="center"
/>
```

上方代码：宽度占满父布局，即宽度和父布局一样宽，即手机屏幕宽度；高度包住内容即可

### 3.1.2 设置内容

设置文本内容两种方式

1. 在 XML 文件中通过属性`android:text`设置文本
2. 在 Java 代码中调用文本视图对象的`setText`方法设置文本

**示例：**

`xml`文件内为第一种方式

`java`文件内为第二种方式

新建一个`acticity_text_view`文件

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/tv_hello"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="修改前" />

</LinearLayout>
```

新建一个`TextViewActivity`类，该活动需要在`AndroidMainfest`中注册，并且`exported`为`true`

```java
package com.example.textdisplay_617;

import android.os.Bundle;
import android.widget.TextView;

import androidx.annotation.Nullable;
import androidx.appcompat.app.AppCompatActivity;

public class TextViewActivity extends AppCompatActivity {
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_text_view);
        TextView tv=findViewById(R.id.tv_hello);
        tv.setText(R.string.hello);
    }
}
```

### 3.1.3 设置大小

1. 在 Java 代码中调用`setTextSize`方法，即可指定文本大小,
2. 在 XML 文件中则通过属性`android:textSize`指定文本大小，此时需要指定字号单位。

* px：它是手机屏幕的最小显示单位，与设备的显示屏有关。
* dp：它是与设备无关的显示单位，只与**屏幕的尺寸**有关。
* sp：它专门用来设置字体大小，在**系统设置**中可以调整字体大小。

|         名称         |                             解释                             |
| :------------------: | :----------------------------------------------------------: |
|   px（Pixel像素）    | 是作为图像构成的基本单元，单个像素的大小并不固定，跟随屏幕大小和像素数量的关系变化，一个像素点为1px。 |
| Resolution（分辨率） | 是指屏幕的垂直和水平方向的像素数量，如果分辨率是1920*1080，那就是垂直方向有1920个像素，水平方向有1080个像素。 |
|    Dpi (像素密度)    |   是指屏幕上每英寸（1英寸=2.54厘米）距离中有多少个像素点。   |
|    Density(密度)     |   是指屏幕上每平方英寸（2.54^2平方厘米）中含有的像素点数量   |
| Dip （设备独立像素） | 也可以叫做dp，长度单位，同一个单位在不同的设备上有不同的显示效果，具体效果根据设备的密度有关 |

对于相同分辨率的手机，屏幕越大，同DP的组件占用屏幕比例越小

对于相同尺寸的手机，即使分辨率不同，同DP的组件占用屏幕比例也相同。

==dp的UI效果只在相同尺寸的屏幕上相同，如果尺寸差异过大，则需要重做dp适配==

**示例**：

**方法一**：

```java
public class TextSizeActivity extends AppCompatActivity {

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_text_size);
        TextView tv = findViewById(R.id.tv_hello);
        tv.setTextSize(50);
    }
}
```

`setTextSize`一个参数的方法默认使用sp

方法二：

```xml
 <TextView
        android:id="@+id/tv_hello"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello"
        android:textSize="30px"/>
```

### 3.1.4 设置颜色

在 Java 代码中调用 setTextColor 方法即可设置文本颜色，具体色值可从 Color 类取

在XML文件中则通过属性`android:textColor`指定文本颜色，色值由透明度`alpha`和`RGB`三原色（红色red、绿色green、蓝色blue）联合定义。

> 色值有==八位==十六进制数与==六位==十六进制数两种表达方式
>
> 例如八位编码FFEEDDCC中，前两位FF表示透明度，EE表示红色的浓度，DD表示绿色的浓度，CC表示蓝色的浓度。
>
> * 透明度为FF表示完全不透明，为00表示完全透明。
> * RGB三色的数值越大，表示颜色越浓，也就越亮；数值越小，表示颜色越淡，也就越暗。

1. ###### **文字颜色**

* java代码

```java
tv.setTextColor(0xFF0000);
```

java代码中只写六位的方法默认为`00`完全透明

* xml代码

```xml
 <TextView
        android:id="@+id/tv_hello2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@string/hello"
        android:textColor="#FF0000" />
```

xml代码中只写六位默认为`FF`完全不透明

2. **背景颜色**

* java代码

```java
		TextView tv_code_background = findViewById(R.id.tv_hello2);
		tv_code_background.setBackgroundColor(Color.GRAY);
//       tv_code_background.setBackgroundResource(R.color.customcolor);
```

* xml代码

```xmml
        android:background="@color/customcolor"/>
```

## 3.2 视图基础

### 3.2.1 设置视图的宽高

1. **xml中**

视图宽度通过属性`android:layout width`表达

视图高度通过属性`android:layout height`表达

宽高的取值主要有下列三种：

* `match_parent`：表示与上级视图保持一致
* `wrap_content`：表示与内容自适应
* 以dp为单位的具体尺寸

2. **java代码中**

1> 首先确保XML中的宽高属性值为`wrap_content`

2> 打开该页面对应的Java代码,依序执行以下三个步骤：

1. 调用控件对象的getLayoutParams方法，获取该控件的布局参数。
2. 布局参数的width属性表示宽度，height属性表示高度，修改这两个属性值
3. 调用控件对象的setLayoutParams方法，填入修改后的布局参数使之生效。

示例：

```java
TextView textView = findViewById(R.id.textView);
// 获取tv_code的布局参数，内部类
ViewGroup.LayoutParams layoutParams = textView.getLayoutParams();
// 修改布局参数中的宽度数值，注意默认px单位，需要把dp数值转成px数值
layoutParams.width = 200; // 宽度
layoutParams.height = 100; // 高度
// 设置tv_code参数
textView.setLayoutParams(layoutParams);
```

### 3.2.2 设置视图的间距

设置视图的间距有两种方式：

* 采用`layout_margin`属性，它指定了当前视图与周围平级视图之间的距离。包括`layout_margin`、`layout_marginLeft`、`layout_marginTop`、`layout_marginRight`、`layout_marginBottom`
* 采用`padding`属性，它指定了当前视图与内部下级视图之间的距离。包括`padding`、`paddingLeft`、`paddingTop`、`paddingRight`、`paddingBottom`

设置间距，`layout_margin`指的是当前视图与外部视图(包括上级视图和平级视图)之间的距离，而`padding`指的是当前视图与内部视图(包括下级视图和内部文本)之间的距离

![6.25](https://raw.githubusercontent.com/betteryuxuan/Image/main/6.25.png)

示例：

```xml
<?xml version="1.0" encoding="utf-8"?>
<!--外部布局背景为蓝色-->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"        <!-- 设置外部布局的宽度为父布局的宽度 -->
    android:layout_height="500dp"              <!-- 设置外部布局的高度为500dp -->
    android:background="#00AAFF"               
    android:orientation="vertical">            <!-- 设置外部布局的方向为垂直方向 -->

    <!--中间层布局背景为黄色-->
    <LinearLayout
        android:layout_width="match_parent"    <!-- 设置中间层布局的宽度为父布局的宽度 -->
        android:layout_height="match_parent"   <!-- 设置中间层布局的高度为父布局的高度 -->
        android:layout_margin="20dp"           <!-- 设置中间层布局的外边距为20dp -->
        android:background="#FFFF99"           
        android:padding="80dp">                <!-- 设置中间层布局的内边距为80dp -->

        <!--最内层视图背景为亮黄色-->
        <View
            android:layout_width="match_parent"  <!-- 设置视图的宽度为父布局的宽度 -->
            android:layout_height="match_parent" <!-- 设置视图的高度为父布局的高度 -->
            android:background="#FFEB3B" />      
    </LinearLayout>
</LinearLayout>
```

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/6.15《2》.jpg" alt="6.15《2》" style="zoom:25%;" />

### 3.2.3 设置视图的对齐方式

有两种途径：

* 采用`layout_gravity`属性，它指定了当前视图相对于上级视图的对齐方式
* 采用`gravity`属性，它指定了下级视图相对于当前视图的对齐方式

`layout _gravity`与`gravity`的取值包括：`left`、`top`、`right`、`bottom`，

还可以用竖线连接各取值，例如“left|top”表示即靠左又靠上，也就是朝左上角对齐。

示例：

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="300dp"
    android:background="#CDDC39"
    android:orientation="horizontal">

    <!-- 第一个嵌套的 LinearLayout -->
    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="200dp"
        android:layout_gravity="bottom"  <!-- 父布局中的对齐方式 -->
        android:layout_margin="10dp"
        android:layout_weight="1"  <!-- 权重，使其占据剩余空间 -->
        android:background="#ff0000"
        android:gravity="left"  <!-- 子布局内部内容的对齐方式 -->
        android:padding="10dp">

        <!-- 内部的 View -->
        <View
            android:layout_width="100dp"
            android:layout_height="100dp"
            android:background="#2196F3" />

    </LinearLayout>

    <!-- 第二个嵌套的 LinearLayout -->
    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="200dp"
        android:layout_gravity="top"  <!-- 父布局中的对齐方式 -->
        android:layout_margin="10dp"
        android:layout_weight="1"  <!-- 权重，使其占据剩余空间 -->
        android:background="#ff0000"
        android:gravity="right|bottom"  <!-- 子布局内部内容的对齐方式 -->
        android:padding="10dp">

        <!-- 内部的 View -->
        <View
            android:layout_width="100dp"
            android:layout_height="100dp"
            android:background="#2196F3" />
    </LinearLayout>

</LinearLayout>
```

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240625231524925.png" alt="image-20240625231524925" style="zoom: 50%;" />

在 Android 中，`layout_weight` 是用来控制布局中子元素分配剩余空间的属性。

如果一个==父布局==的宽度或高度设置为 `match_parent`（即占据父布局的全部空间），并且它的==子元素==的宽度或高度设置为 `0dp`，那么这些子元素将会根据它们的 `layout_weight` 属性来分配剩余的空间。

>`layout_weight` 的默认值是 `0`，表示不占据剩余空间；而设置为大于 `0` 的值（比如 `1`）则表示该子元素在分配剩余空间时的相对权重。例如，如果父布局剩余空间为 300dp，并且有两个子元素，一个 `layout_weight` 设置为 `1`，另一个为 `2`，则第一个子元素将获得 `(1 / (1 + 2)) * 300dp = 100dp`，第二个子元素将获得 `(2 / (1 + 2)) * 300dp = 200dp`。

> 给每个嵌套的 `LinearLayout` 设置了 `layout_weight="1"`，这意味着它们会平均地占据父布局中剩余的空间。这样做可以使两个嵌套的 `LinearLayout` 在水平方向上平分父布局的空间，因为父布局的 `layout_width` 是 `match_parent`。

## 3.3 常用控件

### 3.3.1 TextView

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <TextView
        android:id="@+id/text_view"//给当前控件唯一标识符
        android:layout_width="match_parent"//宽
        android:layout_height="wrap_content"//高
        android:textSize="24sp"//字体大小
        android:textColor="#00ff00"//文本颜色
        android:text="xiaoduyyy"//文本内容
        android:gravity="center"/>//对齐方式

</LinearLayout>
```

### 3.3.2 Button

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <Button
        android:id="@+id/button"//唯一标识符
        android:layout_width="match_parent"//宽
        android:layout_height="wrap_content"//高
        android:text="Button"//内容
        android:textAllCaps="false"/>//是否进行大写转换

</LinearLayout>
```

> 可以在MainActivity中为Button点击事件注册一个监听器

```java
public class MainActivity extends AppCompatActivity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                //添加内容
            }
        });
    }
}
```

### 3.3.3 EditText

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <EditText
        android:id="@+id/edit_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:hint="请输入您的名称"//提示信息
        android:maxLines="2"/>//限制行数
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="确定"
        android:textAllCaps="false"/>
</LinearLayout>
```

```java
public class MainActivity extends AppCompatActivity {
    private EditText editText;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);//获取实例
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String inputText = editText.getText().toString() + "，你好";//获取文本并转换为字符串
                Toast.makeText(MainActivity.this, inputText, Toast.LENGTH_SHORT).show();//打印
            }
        });
    }
}
```

### 3.3.4 ImageView

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ImageView
        android:id="@+id/image_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:src="@drawable/img_1"/>//指定图片
    <Button
        android:id="@+id/button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="点击更换图片"/>
</LinearLayout>
```

> 实现更换图片需要子啊MainActivity中进行修改

```java
public class MainActivity extends AppCompatActivity {
    private ImageView imageView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        imageView = (ImageView) findViewById(R.id.image_view);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imageView.setImageResource(R.drawable.img_2);//更换图片
            }
        });
    }
}
```

### 3.3.5 ProgressBar

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">
    <ProgressBar
        android:id="@+id/progress_bar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        style="?android:attr/progressBarStyleHorizontal"/>//更换样式
</LinearLayout>
```

> 可以通过点击来让进度条显示或者消失

```java
public class MainActivity extends AppCompatActivity {
    private ImageView imageView;
    private ProgressBar progressBar;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        imageView = (ImageView) findViewById(R.id.image_view);//获取实例
        progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imageView.setImageResource(R.drawable.img_2);
                if(progressBar.getVisibility() == View.GONE) {//判断隐藏或显示
                    progressBar.setVisibility(View.VISIBLE);
                }
                else {
                    progressBar.setVisibility(View.GONE);
                }
            }
        });
    }
}
```

也可以更新进度条

```java
public class MainActivity extends AppCompatActivity {
    private ImageView imageView;
    private ProgressBar progressBar;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        imageView = (ImageView) findViewById(R.id.image_view);
        progressBar = (ProgressBar) findViewById(R.id.progress_bar);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                imageView.setImageResource(R.drawable.img_2);
                int progress = progressBar.getProgress();
                progressBar.setProgress(progress + 10);
            }
        });
    }
}
```

### 3.3.6 AlertDialog

弹出一个窗口来提示用户

```java
public class MainActivity extends AppCompatActivity {
    private ImageView imageView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        imageView = (ImageView) findViewById(R.id.image_view);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);
                dialog.setTitle("提示标题");
                dialog.setMessage("重要提示");
                dialog.setCancelable(false);
                dialog.setPositiveButton("确定", new DialogInterface.OnClickListener() {//设置确定按钮事件
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                dialog.setNegativeButton("取消", new DialogInterface.OnClickListener() {//设置取消按钮事件
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                    }
                });
                dialog.show();
            }
        });
    }
}
```

### 3.3.7 ProgressDialog

和AlertDialog类似，但是弹出的是进度条

```java
public class MainActivity extends AppCompatActivity {
    private ImageView imageView;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        imageView = (ImageView) findViewById(R.id.image_view);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                ProgressDialog progressDialog = new ProgressDialog(MainActivity.this);
                progressDialog.setTitle("提示标题");
                progressDialog.setMessage("加载中...");
                progressDialog.setCancelable(false);//是否可以取消
                progressDialog.show();
            }
        });
    }
}
```

## 3.3 常用布局

### 3.3.1 线性布局



### 3.3.2 相对布局

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <Button
        android:id="@+id/button1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="button1" />

    <Button
        android:id="@+id/button2"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentLeft="true"
        android:layout_alignParentBottom="true"
        android:text="button2" />

    <Button
        android:id="@+id/button3"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_toRightOf="@+id/button1"
        android:layout_above="@+id/button1"
        android:text="button3" />

</RelativeLayout>
```

### 3.3.3 帧布局

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:text="会当凌绝顶  一览众山小" />

    <ImageView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="right"
        android:src="@mipmap/ic_launcher" />
</FrameLayout>
```

### 3.3.4 网格布局

GridLayout

网格布局支持多行多列的表格排列

网格布局默认从左往右、从上到下排列，它新增了两个属性：

* `columnCount`属性，它指定了网格的列数，即每行能放多少个视图；
* `rowCount`属性，它指定了网格的行数，即每列能放多少个视图；

```xml
<?xml version="1.0" encoding="utf-8"?>
<GridLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:columnCount="2"
    android:rowCount="2">

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_columnWeight="1"
        android:background="#C077FF"
        android:gravity="center"
        android:text="第一格"
        android:textSize="40dp" />

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_columnWeight="1"
        android:background="#B2E300"
        android:gravity="center"
        android:text="第二格"
        android:textSize="40dp" />

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_columnWeight="1"
        android:background="#A8AAAE"
        android:gravity="center"
        android:text="第三格"
        android:textSize="40dp" />

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_columnWeight="1"
        android:background="#B62939"
        android:gravity="center"
        android:text="第四格"
        android:textSize="40dp" />

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_columnWeight="1"
        android:background="#CBFF10"
        android:gravity="center"
        android:text="第五格"
        android:textSize="40dp" />

</GridLayout>
```

![image-20240715201450475](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240715201450475.png)

### 3.3.5 约束布局

## 3.4 自定义控件 

### 3.4.1 引入布局

自定义标题栏

![image-20240716162743604](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240716162743604.png)

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:background="#FF0000">

    <Button
        android:id="@+id/button_back"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:backgroundTint="#8BC34A"
        android:text="返回" />

    <TextView
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_weight="1"
        android:gravity="center"
        android:text="当前页"
        android:textColor="#FFFFFF"
        android:textSize="25dp" />

    <Button
        android:id="@+id/button_edit"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_margin="5dp"
        android:backgroundTint="#8BC34A"
        android:text="退出" />
</LinearLayout>
```

布局文件中直接引入

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 引入另一个布局文件 -->
    <include layout="@layout/title"/>

</LinearLayout>
```

### 3.4.2 自定义控件

### 3.4.3 ListView

### 3.4.4 RecyclerView

==1. 横向滚动==

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/716.jpg" alt="716" style="zoom:25%;" />

主活动类 `MainActivity.java`

```java
package com.example.recyclerview;

import android.os.Bundle;

import androidx.appcompat.app.AppCompatActivity;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;

import java.util.ArrayList;
import java.util.List;

public class MainActivity extends AppCompatActivity {
    private List<Fruit> fruitList = new ArrayList<>();

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        // 初始化水果数据
        initFruits();

        // 获取RecyclerView实例并设置布局管理器
        RecyclerView recyclerView = findViewById(R.id.recycler_view);
        LinearLayoutManager layoutManager = new LinearLayoutManager(this);
        layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); // 设置水平布局
        recyclerView.setLayoutManager(layoutManager);

        // 创建适配器并将其设置到RecyclerView上
        FruitAdapter adapter = new FruitAdapter(fruitList);
        recyclerView.setAdapter(adapter);
    }

    // 初始化水果数据的方法
    private void initFruits() {
        // 添加水果数据
        fruitList.add(new Fruit("Apple", R.drawable.apple));
        fruitList.add(new Fruit("Banana", R.drawable.banana));
        fruitList.add(new Fruit("Litchi", R.drawable.litchi));
        // 可以继续添加其他水果数据
    }
}
```

适配器类 `FruitAdapter.java`

```java
package com.example.recyclerview;

import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import androidx.annotation.NonNull;
import androidx.recyclerview.widget.RecyclerView;

import java.util.List;

public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {
    private List<Fruit> mFruitList;

    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }

    // ViewHolder类，用于缓存视图中的控件实例
    static class ViewHolder extends RecyclerView.ViewHolder {
        ImageView fruitImage;
        TextView fruitName;

        ViewHolder(View itemView) {
            super(itemView);
            fruitImage = itemView.findViewById(R.id.fruit_image); // 关联布局文件中的ImageView控件
            fruitName = itemView.findViewById(R.id.fruit_name);   // 关联布局文件中的TextView控件
        }
    }

    // 创建ViewHolder实例并绑定布局文件
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);
        return new ViewHolder(view);
    }

    // 将数据绑定到ViewHolder中的控件实例
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        Fruit fruit = mFruitList.get(position);
        holder.fruitImage.setImageResource(fruit.getImageId()); // 设置ImageView的图片资源
        holder.fruitName.setText(fruit.getName());               // 设置TextView的文本内容
    }

    // 返回数据集合的大小
    @Override
    public int getItemCount() {
        return mFruitList.size();
    }
}
```

数据模型类 `Fruit.java`

```java
package com.example.recyclerview;

public class Fruit {
    private String name;
    private int imageId;

    // 构造方法，用于初始化水果的名称和图片资源ID
    public Fruit(String name, int imageId) {
        this.name = name;
        this.imageId = imageId;
    }

    // 获取水果名称
    public String getName() {
        return name;
    }

    // 获取水果图片资源ID
    public int getImageId() {
        return imageId;
    }
}
```

主布局文件 `activity_main.xml`

```xml
xmlCopy code<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</LinearLayout>
```

列表项布局文件 `fruit_item.xml`

```xml
xmlCopy code<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="100dp"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:layout_gravity="center_horizontal"
        android:scaleType="centerCrop" />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:layout_marginTop="10dp"
        android:textSize="20dp" />
</LinearLayout>
```

==2.瀑布流==

**在水果样式的布局文件中**

宽度使用`match_parent`，文字左对齐

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_margin="5dp"
    android:orientation="vertical">

    <ImageView
        android:id="@+id/fruit_image"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:layout_gravity="center_horizontal"
        android:scaleType="centerCrop" />

    <TextView
        android:id="@+id/fruit_name"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="left"
        android:layout_marginTop="10dp"
        android:textSize="20dp" />
</LinearLayout>
```

**在MainActivity中**

```java
StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL);
```

创建一个`StaggeredGridLayoutManager`示例，第一个参数列数，第二个参数指定布局的排列方向

3. ==点击事件==

<img src="https://raw.githubusercontent.com/betteryuxuan/Image/main/717.jpg" alt="717" style="zoom:25%;" />

```java
public class FruitAdapter extends RecyclerView.Adapter<FruitAdapter.ViewHolder> {
    // 保存水果数据的列表
    private List<Fruit> mFruitList;

    // ViewHolder类，用于持有RecyclerView子项的各个视图
    static class ViewHolder extends RecyclerView.ViewHolder {
        ImageView fruitImage;
        TextView fruitName;
        View fruitView;

        // 构造函数，接收一个View参数并通过findViewById初始化子项视图
        public ViewHolder(View view) {
            super(view);
            fruitView = view;
            fruitImage = view.findViewById(R.id.fruit_image);
            fruitName = view.findViewById(R.id.fruit_name);
        }
    }

    // 构造函数，接收一个水果列表并赋值给成员变量mFruitList
    public FruitAdapter(List<Fruit> fruitList) {
        mFruitList = fruitList;
    }

    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        // 创建一个ViewHolder实例，加载子项布局
        View view = LayoutInflater.from(parent.getContext())
                .inflate(R.layout.fruit_item, parent, false);
        final ViewHolder holder = new ViewHolder(view);

        // 设置点击监听器，当点击整个子项时，显示水果名称的Toast消息
        holder.fruitView.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 获取当前项在适配器中的位置
                int position = holder.getAdapterPosition();
                // 获取相应位置的水果实例
                Fruit fruit = mFruitList.get(position);
                // 显示包含水果名称的Toast消息
                Toast.makeText(v.getContext(), "你点击了" + fruit.getName(), Toast.LENGTH_SHORT).show();
            }
        });

        // 设置点击监听器，当点击水果图片时，显示包含水果名称和“的图片”的Toast消息
        holder.fruitImage.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                // 获取当前项在适配器中的位置
                int position = holder.getAdapterPosition();
                // 获取相应位置的水果实例
                Fruit fruit = mFruitList.get(position);
                // 显示包含水果名称和“的图片”的Toast消息
                Toast.makeText(v.getContext(), "你点击了" + fruit.getName() + "的图片", Toast.LENGTH_SHORT).show();
            }
        });

        return holder;
    }

    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        // 获取当前项的水果实例
        Fruit fruit = mFruitList.get(position);
        // 设置水果图片和名称
        holder.fruitImage.setImageResource(fruit.getImageId());
        holder.fruitName.setText(fruit.getName());
    }

    @Override
    public int getItemCount() {
        // 返回水果列表的大小
        return mFruitList.size();
    }
}
```

1. 新增`View fruitView`，用于保存对子项视图的引用，便于操作子项
2.  `View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false);`

**`LayoutInflater.from(parent.getContext())`**：

- `LayoutInflater` 是一个用于将 XML 布局文件解析成对应的 `View` 对象的类。
- `from(Context context)` 方法获取一个 `LayoutInflater` 对象，这里使用的是 `parent.getContext()` 作为上下文。`parent` 是 `ViewGroup` 类型的参数，表示 `RecyclerView` 本身。

**`.inflate(R.layout.fruit_item, parent, false)`**：

- `inflate` 方法将指定的 XML 布局文件解析为一个 `View` 对象。
- `R.layout.fruit_item` 是布局文件的资源 ID，指向 `res/layout/fruit_item.xml` 文件。
- `parent` 是 `ViewGroup` 类型的参数，它是 `RecyclerView` 的父视图，用于确定新视图的宽度和高度。
- `false` 表示不要将解析出来的 `View` 附加到 `parent` 视图中。因为 RecyclerView 会负责将该子项视图添加到其自身中。

3.`final ViewHolder holder = new ViewHolder(view);`

创建了`ViewHolder`实例，将一个具体的布局视图和一个 `ViewHolder`实例关联起来。之后就可以通过该**实例对象**访问布局视图的各个组件，进行操作

### 3.4.5 ScrollView

* ScrollView，它是垂直方向的滚动视图；

垂直方向滚动时，内部的子布局`layout_width`属性值设置为`match_parent`，`layout_height`属性值设置为`wrap_content`。

* HorizontalScrollView，它是水平方向的滚动视图；

水平方向滚动时，`layout_width`属性值设置为`wrap_content`，`layout_height`属性值设置为`match_parent`。

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="300dp">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <View
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:background="#aaffff" />

            <View
                android:layout_width="match_parent"
                android:layout_height="200dp"
                android:background="#aaaaaa" />
        </LinearLayout>
    </ScrollView>

    <HorizontalScrollView
        android:layout_width="wrap_content"
        android:layout_height="300dp">

        <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:orientation="horizontal">

            <View
                android:layout_width="300dp"
                android:layout_height="match_parent"
                android:background="#aaffff" />

            <View
                android:layout_width="300dp"
                android:layout_height="match_parent"
                android:background="#fff000" />
        </LinearLayout>
    </HorizontalScrollView>

</LinearLayout>
```





### 3.4.6 界面编写

# 四、碎片

## 4.1 使用方式

`left_fragment`

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <Button
        android:id="@+id/button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="Button1" />

</LinearLayout>
```

`right_fragment`

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="新闻1"
        android:textSize="40dp"/>


</LinearLayout>
```

`LeftFragment.java`

```java
public class LeftFragment extends Fragment {
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.left_fragment,container,false);
        return view;
    }
}
```

`RightFragment`

```java
public class RightFragment extends Fragment {
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
}
```

`activity_main.xml`

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">

    <fragment
        android:id="@+id/left_fragment"
        android:name="com.example.fragmenttest.LeftFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

    <fragment
        android:id="@+id/right_fragment"
        android:name="com.example.fragmenttest.RightFragment"
        android:layout_width="0dp"
        android:layout_height="match_parent"
        android:layout_weight="1" />

</LinearLayout>
```

## 4.2 动态添加碎片

**步骤**：

1. 创建待添加的碎片实例。
2. 获取`FragmentManager`,在活动中可以直接通过调用`getSupportFragmentManager()`方法得到。
3. 开启一个事务，通过调用`beginTransaction()`方法开启。
4. 向容器内添加或替换碎片，一般使用`replace()`方法实现，需要传入容器的id和待添加的碎片实例。
5. 提交事务，调用`commit()`方法来完成。



新建another_right_fragment.xml，更改了文字内容

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#252525"
    android:orientation="vertical">

    <TextView
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_gravity="center_horizontal"
        android:text="新闻2"
        android:textColor="@color/white"
        android:textSize="100dp" />
</LinearLayout>
```

新建`AnotherRightFragment`类

```java
public class AnotherRightFragment extends Fragment {
    @Nullable
    @Override
    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.another_right_fragment, container, false);
        return view;
    }
}
```

`MainActivity`中

```java
package com.example.fragmenttest;

import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import androidx.activity.EdgeToEdge;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.graphics.Insets;
import androidx.core.view.ViewCompat;
import androidx.core.view.WindowInsetsCompat;
import androidx.fragment.app.Fragment;
import androidx.fragment.app.FragmentManager;
import androidx.fragment.app.FragmentTransaction;

public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        Button button = (Button) findViewById(R.id.button);
        button.setOnClickListener(this);
        replaceFragment(new RightFragment());
    }

    @Override
    public void onClick(View v) {
        replaceFragment(new AnotherRightFragment());
    }

    private void replaceFragment(Fragment fragment) {
        // 获取FragmentManager的实例, FragmentManager用于管理Fragment，包括添加、移除和替换Fragment
        FragmentManager fragmentManager = getSupportFragmentManager();
        // 获取FragmentTransaction的实例, FragmentTransaction用于执行一组Fragment操作，例如添加、移除、替换等
        FragmentTransaction transaction = fragmentManager.beginTransaction();
        // 将fragment替换到指定的容器（R.id.right_layout）中
        transaction.replace(R.id.right_layout, fragment);
        // 所有这些操作在调用commit()之前是临时的，只有在调用commit()之后才会应用
        transaction.commit();
    }
}
```

`replaceFragment`方法的功能是：

当需要动态替换当前界面的某一部分时，通过`FragmentManager`和`FragmentTransaction`来实现。这个方法首先获取`FragmentManager`实例，然后开始一个事务，使用`replace()`方法将指定的`Fragment`添加到指定的容器中，最后提交事务以应用变化。

在你的`MainActivity`中，这个方法在`onCreate`方法中被调用，用于初始化显示一个Fragment（`RightFragment`），并在按钮点击事件中再次调用，用于替换成另一个Fragment（`AnotherRightFragment`）。这样可以在用户交互时动态更新界面内容。

## 4.3 碎片和活动间通信

* 在`MainActivity`中

使用 `FragmentManager` 从活动中获取已添加到布局中的 `Fragment` 实例：

```java
Fragment fragment = getSupportFragmentManager().findFragmentById(R.id.left_fragment);
```

* 在`Fragment`中

使用 `getActivity()` 方法获取当前的 `Activity` 实例：

```java
MainActivity activity = (MainActivity) getActivity();
```



## 4.4 限定符

### 4.4.1 使用限定符

> 通过使用限定符，你可以为不同的设备配置、语言、屏幕大小等提供专门的资源，从而提高应用的适应性和用户体验。

![image-20240722114655244](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240722114655244.png)

![image-20240722114858501](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240722114858501.png)

### 4.4.2 使用最小宽度限定符

![image-20240722115138595](C:/Users/HP/AppData/Roaming/Typora/typora-user-images/image-20240722115138595.png)

![image-20240722115235492](https://raw.githubusercontent.com/betteryuxuan/Image/main/image-20240722115235492.png)
