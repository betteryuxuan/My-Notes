# 高内聚低耦合

提高代码的可读性、可维护性和可扩展性，降低开发和维护的成本，并减少系统的风险

内聚：

> 内聚表示**一个模块内部**各个元素之间相互关联的程度。
>
> 高内聚意味着模块内部的功能紧密相关，所有部分都共同完成一个特定的任务或功能。
>
> 低内聚则意味着模块内部包含多种不相关的功能。

耦合：

> 耦合表示**不同模块之间**相互依赖的程度。
>
> 高耦合意味着模块之间相互依赖紧密，一个模块的变化会影响到其他模块。
>
> 低耦合则意味着模块之间相对独立，一个模块的变化对其他模块的影响较小。

举个例子：

> 汽车是由许多不同的部件组成的，比如发动机、轮胎、刹车等等。
>
> 在高内聚低耦合的设计中，每个部件都应该专注于自己的功能，同时尽可能减少与其他部件之间的依赖关系。
>
> 高内聚意味着每个部件都应该有一个清晰的责任和功能。发动机的责任是提供动力，而刹车系统的责任是提供制动。这样设计的好处是，每个部件都可以独立工作，而不需要过多依赖其他部件的内部细节。
>
> 低耦合意味着部件之间的相互依赖应该尽可能减少。刹车系统不需要知道发动机如何工作，它只需要知道何时需要制动。这样设计的好处是，如果需要更改或替换一个部件，不会对其他部件产生太大影响，因为它们之间的依赖关系很少。

高内聚：意味着一个类或模块的内部元素（包括变量、方法和属性）应该紧密相关，并且共同服务于一个明确且集中的目的。

低耦合：模块或类之间的依赖关系应该尽可能少

> - **内紧**（高内聚）：程序内的模块或类应该紧密相关，形成一个高效的功能单元。
> - **外松**（低耦合）：程序之间的模块或类应该尽可能不关联，各自实现各自的功能。

| 权限修饰符  | 同类 | 同包 | 子类（不同包） | 其他包 |
| ----------- | ---- | ---- | -------------- | ------ |
| `private`   | ✔    | ✘    | ✘              | ✘      |
| `default`   | ✔    | ✔    | ✘              | ✘      |
| `protected` | ✔    | ✔    | ✔              | ✘      |
| `public`    | ✔    | ✔    | ✔              | ✔      |

# 设计原则

在进行软件系统设计时所要遵循的一些经验准则，应用该准则的目的通常是为了避免某些经常出现的设计缺陷，提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性

包括单一职责原则，开放封闭原则，里氏替换原则，依赖倒置原则，迪米特原则，接口隔离原则

## 开闭原则

（Open-Closed Principle, OCP）

**定义**：类，模块，函数等应该是可以拓展的，但是不可修改

> 对扩展开放，对修改关闭。

我们需要使用抽象实现（接口和抽象类）达到这样的效果。

因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。

而软件中易变的细节可以<u>从抽象派生来的实现类来进行扩展</u>，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。

举个例子

```java
//AbstractSkin.java
public abstract class AbstractSkin {
    //显示皮肤
    public abstract void display();
}

//DefaultSkin.java
public class DefaultSkin extends AbstractSkin{
    @Override
    public void display() {
        System.out.println("默认皮肤");
    }
}

//WhiteSkin.java
public class WhiteSkin extends AbstractSkin{
    @Override
    public void display() {
        System.out.println("白色皮肤");
    }
}

//SougouInput.java
public class SougouInput {
    private AbstractSkin skin;

    public AbstractSkin getSkin() {
        return skin;
    }
	//通过setSkin方法设置不同的皮肤实现
    public void setSkin(AbstractSkin skin) {
        this.skin = skin;
    }

    public void display() {
        skin.display();
    }
}

//Client.java
public class Client {
    public static void main(String[] args) {
        //1.创建输入法对象
        SougouInput input = new SougouInput();
        //2.创建皮肤对象
        DefaultSkin skin = new DefaultSkin();
      //WhiteSkin skin = new WhiteSkin();
        //3.将皮肤设置到输入法中
        input.setSkin(skin);
        //4.显示皮肤
        input.display();
    }
}

```

`SougouInput` 类通过其 `setSkin` 方法允许添加不同类型的皮肤（如 `DefaultSkin` 或 `WhiteSkin`），这体现了对扩展的开放性。

由于 `SougouInput` 类依赖于 `AbstractSkin` 抽象类而不是具体的皮肤实现类，因此添加新的皮肤类型只需要创建新的子类并实现 `AbstractSkin` 的 `display` 方法，而<u>不需要修改 `SougouInput` 类的代码</u>。这体现了对修改的封闭性。

皮肤的类不用修改，再创建新皮肤，让他继承`AbstractSkin`抽象类，在客户端类代码进行修改即可。

**作用**：

1. 提高软件的可维护性
2. 增强软件的扩展性
3. 减少代码的耦合度

## 单一职责原则

（Single Responsibility Principle，SRP）

**定义**：一个类（或模块、函数等）应该只有一个引起它变化的原因。换句话说，一个类应该只负责一个功能领域中的相关职责，或者变化的原因应该只有一个。

下面是不符合单一职责原则的例子：

```java
public class TelPhone {
    public void Dial(String phone_number){
        System.out.println("给"+phone_number+"打电话");
    }

    public void HangUp(String phone_number) {
        System.out.println("挂断" + phone_number + "打电话");
    }

    public void SendMessage(String message) {
        System.out.println("发送" + message);
    }

    public void ReceiveMessage(String message) {
        System.out.println("接收" + message);
    }
}
```

可能发生的变化：

1. 内部的变化，如果 `TelPhone` 类中的任何一个方法发生改变，，都需要修改`TeIPhone`、由于它负责了多个职责，所以一个职责的变化可能会导致其他无关职责的代码也需要被修改或重新测试。

2. 外部的变化，如果`TeIPhone`要添加新的的方法，需要修改`TeIPhone`类

为了符合单一职责原则，我们可以做出如下修改：

但中间的依然不符合，存在一个以上引起类变化的原因，所以我们可以考虑最右边的，一个类中只有一个方法

![yuanze2](https://raw.githubusercontent.com/betteryuxuan/Image/main/yuanze2.png)

但这样比较极端，会导致类的数量大幅增加，使得管理和维护代码变得复杂。

因此，我们通常要在单一职责原则和实际应用之间找到一个平衡点。

实现方式：

给每个方法，都提炼成一个接口，抽象成一种能力，然后分别写类，去实现接口，最终在`TelPhone`中只进行调用。

```java
package com.feng.test01;

interface Dialer {
    void Dial(String phoneNumber);
}

interface Hanger {
    void HangUp();
}

interface Sender {
    void SendMessage(String text);
}

interface Receiver {
    void ReciveMessage(String text);
}


class DialerImpl implements Dialer {
    public void Dial(String phoneNumber) {
        System.out.println("给 " + phoneNumber + " 打电话");
    }
}

class HangerImpl implements Hanger {
    public void HangUp() {
        System.out.println("挂断电话");
    }
}

class SenderImpl implements Sender {
    public void SendMessage(String text) {
        System.out.println("发送 " + text);
    }
}

class ReceiverImpl implements Receiver {
    public void ReciveMessage(String text) {
        System.out.println("接收 " + text);
    }
}

class TelPhone {
    private Dialer dialer;
    private Hanger hanger;
    private Sender sender;
    private Receiver receiver;

    public TelPhone(Dialer dialer, Hanger hanger, Sender sender, Receiver receiver) {
        this.dialer = dialer;
        this.hanger = hanger;
        this.sender = sender;
        this.receiver = receiver;
    }

    public void Dial(String phoneNumber) {
        dialer.Dial(phoneNumber);
    }

    public void HangUp() {
        hanger.HangUp();
    }

    public void SendMessage(String text) {
        sender.SendMessage(text);
    }

    public void ReciveMessage(String text) {
        receiver.ReciveMessage(text);
    }
}

public class Main {
    public static void main(String[] args) {
        // 创建接口实现类实例
        Dialer dialer = new DialerImpl();
        Hanger hanger = new HangerImpl();
        Sender sender = new SenderImpl();
        Receiver receiver = new ReceiverImpl();

        // 创建 TelPhone 对象并使用其接口
        TelPhone telphone = new TelPhone(dialer, hanger, sender, receiver);

        // 电话呼叫操作
        telphone.Dial("123456789");
        telphone.HangUp();

        // 消息操作
        telphone.SendMessage("Hello, World!");
        telphone.ReciveMessage("Hi there!");
    }
}
```

好处：

1. 提高代码的可读性，提高系统的可维护性。
2. 降低类的复杂性，一个模块只负责一个职责，提高系统的可扩展性和可维护性。
3. 降低变更引起的风险。变更是不然的，如果单一职责做得好，当修改一个功能的时候可以显著的降低对另一个功能的影响。



## 里氏代换原则

（Liskov Substitution Principle，LSP）

里氏代换原则：任何基类可以出现的地方，子类一定可以出现。

通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。

要点：

**功能保持**：子类应当能够替代基类，并且子类对象应能代替基类对象使用，而不会导致程序运行出现问题。

**行为一致**：子类可以扩展基类的功能，但不能改变基类的功能。即子类的行为应该与基类保持一致

要求：

1. **子类可以实现父类的抽象方法，但不要去覆盖（重写）父类的非抽象方法**
2. 子类可以增加自己特有的方法
3. 当子类的方法重写父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松
4. 当子类的方法实现父类的方法时（重写或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或与父类一样

```java
package com.feng.test05;

public abstract class Coder {
    public void coding() {
        System.out.println("我会敲代码！");
    }
}

class JavaCoder extends Coder {
    public void play() {
        System.out.println("喜欢玩XXXX");
    }
    //重写了父类的非抽象方法
    public void coding() {
        System.out.println("我只会敲JAVA代码！");
    }
}
```

里氏代换原则指出，如果程序中的对象使用的是基类（父类）的话，那么无论是使用基类对象还是其子类对象，程序的行为都是一致的。

用 `JavaCoder` 替代 `Coder` 时，本来会敲很多代码，但现在只会敲JAVA了。

所以尽量不要去重写父类非抽象方法，不要改变父类原有的功能。

可以这样修改：

1. 保留父类方法的行为，并且扩展子类方法的功能

```java
    public void coding() {
        super.coding(); // 调用父类的coding方法
        System.out.println("我会敲JAVA代码！");
    }
```

2. 或者再写一个`javaCoding`方法
3. 写`JavaCoder`和`Coder`的抽象父类`People`，把`coding`这一行为定义在`People`中，放弃`JavaCoder`和`Coder`的继承关系

**好处**：

1. 开放性：是实现开放封闭原则的的具体手段之一
2. 提高代码的可复用性

## 依赖倒置原则

（Dependence Inversion Principle，DIP）

定义：高层模块不应该依赖低层模块，两者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。

旨在通过依赖于抽象而不是具体实现来降低系统的耦合度，提高系统的可维护性和可扩展性。

下面是一个违背依赖倒置原则的例子

```java
package com.feng.test04;

class FuelCar{
    public void run(){
        System.out.println("开的是燃油车");
    }
}

class Driver{
    public void drive(FuelCar car) {
        car.run();
    }
}

public class Client {
    public static void main(String[] args) {
        FuelCar fuelCar = new FuelCar();
        Driver xiaowang = new Driver();
        xiaowang.drive(fuelCar);
    }
}
```

`Driver` 类直接依赖于 `FuelCar` 类，而没有使用抽象，违反了依赖倒置原则。

如果我们想要支持其他类型的车辆，比如电动车或者公交车，就需要修改 `Driver` 类，这样会增加代码的耦合度和维护成本。

高层模块（`Driver`）不应该直接依赖于低层模块（`FuelCar`），而是应该依赖于抽象。在这个例子中，`Driver` 类应该依赖于一个抽象的 `ICar` 接口，而不是具体的 `FuelCar` 类。

我们可以引入一个接口来表示所有类型的车，并让`FuelCar`实现这个接口。然后，`Driver`的`drive`方法可以接受任何实现了`ICar`接口的对象作为参数。

```java
package com.feng.test04after;

interface ICar {
    void run();
}

class FuelICar implements ICar {
    @Override
    public void run() {
        System.out.println("开的是燃油车");
    }
}

class ElectricICar implements ICar {
    @Override
    public void run() {
        System.out.println("开的是电车");
    }
}

class Driver {
    public void drive(ICar car) {
        car.run();
    }
}

public class Client {
    public static void main(String[] args) {
        ICar su7 = new ElectricICar();
        ICar benz = new FuelICar();
        
        Driver driver = new Driver();
        
        driver.drive(su7);
        driver.drive(benz);
    }
}
```

**作用**：

1. 提高代码的可维护性
2. 降低代码的耦合度
3. 提高系统的可扩展性

## 迪米特原则

（Law of Demeter，LoD）

也称为最少知识原则：一个对象应该对其他对象有最少的了解。

定义：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用

> 一个对象应该对其他对象知之甚少，只与“朋友”通信，而不与“陌生人”直接通信。
>
> * 租房者-中介-房东
> * 要做软件的公司-软件公司-软件工程师

这里的“朋友”指的是当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等

这些对象同当前对象存在关联、依赖、聚合或组合关系，可以直接访问这些对象的方法。

下面是一个

```java
import java.util.ArrayList;
import java.util.List;

class Product {
    private String name;
    private double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }
}

// 购物车类
class ShoppingCart {
    private List<Product> products;

    public ShoppingCart() {
        this.products = new ArrayList<>();
    }

    // 添加商品到购物车
    public void addProduct(Product product) {
        products.add(product);
    }

    // 打印购物车中的商品信息
    public void printCart() {
        for (Product product : products) {
            System.out.println("商品：" + product.getName() + " 价格：" + product.getPrice());
        }
    }
}

public class Test {
    public static void main(String[] args) {
        Product product1 = new Product("banana", 2);
        Product product2 = new Product("apple", 5);

        ShoppingCart cart = new ShoppingCart();

        cart.addProduct(product1);
        cart.addProduct(product2);

        cart.printCart();
    }
}
```

`ShoppingCart` 类对 `Product` 类的了解仅限于 `getName` 和 `getPrice` 方法，这是符合迪米特原则的。`ShoppingCart` 不需要知道 `Product` 类的内部实现细节，也不需要与其他任何与 `Product` 类相关的“陌生人”对象进行交互。

好处：

1. 降低耦合性
2. 提高模块独立性
3. 增强系统的可维护性

## 接口隔离原则

（Interface Segregation Principle，ISP）

**定义**：一个类对另一个类的依赖应该建立在最小的接口上。

建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量少。

也就是说，我们要为各个类建立专用的接口，而不要试图建立一个很庞大的接口件所有依赖它的类通用。

下面是一个不符合接口隔离原则的例子：

```java
package com.feng.test03;

interface Device {
    String getCpu();
    String getType();
    String getMemory();
}
class computer implements Device{

    @Override
    public String getCpu() {
        return "i7";
    }

    @Override
    public String getType() {
        return "笔记本电脑";
    }

    @Override
    public String getMemory() {
        return "16GB";
    }
}

class fan implements Device{

    @Override
    public String getCpu() {
        return null; //不需要的方法
    }

    @Override
    public String getType() {
        return "电风扇";
    }

    @Override
    public String getMemory() {
        return null; //不需要的方法
    }
}
```

虽然定义了一个`Device`接口，但是由于此接口的粒度不够细化，类依赖于不需要的方法。虽然比较契合电脑这种设备，但是不适合风扇，要对其进行更细粒度的划分。

接口的粒度：描述了接口所提供功能的大小和复杂度

下面是一个符合接口隔离原则粒度更细的代码：

```java
// 通用设备接口  
interface GenericDevice {  
    String getType();  
}  
  
// 电脑设备接口  
interface ComputerDevice extends GenericDevice {  
    String getCpu();  
    String getMemory();  
}  
  
// 风扇设备接口  
interface FanDevice extends GenericDevice {
    void adjustSpeed(int speed);  
}  
```

注意：

1. 接口尽量小，但是要有限度。对接口进行细化可以提高程序设计的灵活性；但是如果过小，则会造成接口数量过多，使设计复杂化。所以，接口的大小一定要适度。
2. 为依赖接口的类定制服务，只暴露给调用的类需要的方法，不需要的方法则隐藏起来只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
3. 提高内聚，减少对外交互。接口方法尽量少用`public`修饰。接口是对外的承诺，承诺越少，对系统的开发越有利，变更风险也会越少。

**作用**：

1. 降低耦合性
2. 提高灵活性
3. 增强可维护性

---

1. **开闭原则：抽象架构，扩展实现**
2. **单一职责：一个类和方法只做一件事**
3. **里氏替换： 多态，子类可扩展父类** 
4. **依赖倒置：细节依赖抽象，下层依赖上层**
5. **接口隔离：建立单一接口**
6. **迪米特原则：最少知道，降低耦合**

---



# 创建型设计模式

# 单例模式

## 定义

定义：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个示例

![singleInstance](https://raw.githubusercontent.com/betteryuxuan/Image/main/singleInstance.jpg)

```java
public class Singleton {
    private static final Singleton singleton = new Singleton();

    private Singleton() {
    }

    public static Singleton getSingleton() {
        return singleton;
    }

    public static void doSomething() {
        System.out.println("其他方法");
    }
}
```

## 优缺点

> 优点：
>
> 1. 减少内存开支
> 2. 减少系统性能开销
> 3. 避免资源多重占用
> 4. 可以在设置全局访问点
>
> 缺点：
>
> 1. 没有接口，拓展困难
> 2. 对测试不利，没写完单例测试不了
> 3. 与单一职责原则冲突

## 注意

### 线程不安全

```java
public class Singleton {
    private static Singleton singleton = null;

    private Singleton() {
    }

    public static Singleton getSingleton() {
        if (singleton == null) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

这种方式会有线程不安全的情况，因为初始化需要时间，所以高并发情况下可能会两个线程同时创建对象，就会在内存中出现两个对象

**懒汉式单例**：在方法前加synchronized关键字或方法内添加

**饿汉式单例**：

```java
public class Singleton {
    private static final Singleton singleton = new Singleton();
}
private Singleton() {
}

public static Singleton getSingleton() {
    return singleton;
}
```
### 不建议实现Cloneable接口

**不建议实现 `Cloneable` 接口**，因为 `Cloneable` 的存在会破坏单例的唯一性，导致可能会有多个实例

## 扩展

 



# 工厂模式

## 女娲造人示例

1. Human接口

```java
public interface Human {
    public void getColor();
    public void talk();
}
```

2. Human实现类

```java
public class WhiteHuman implements Human{
    @Override
    public void getColor() {
        System.out.println("白色皮肤");
    }

    @Override
    public void talk() {
        System.out.println("让我们说English");
    }
}

package human;

public class YellowHuman implements Human{
    @Override
    public void getColor() {
        System.out.println("黄色肌肤");
    }

    @Override
    public void talk() {
        System.out.println("让我们说中文");
    }
}
```

3. 抽象工厂定义

```java
public abstract class AbstractHumanFactory {
    public abstract <T extends Human> T createHuman(Class<T> c);
}
```

   传入参数：Class类型，必须是Human的实现类

   返回参数：Human的实现类

4. 抽象工厂定义实现类

```java
public class HumanFactory extends AbstractHumanFactory {
    @Override
    public <T extends Human> T createHuman(Class<T> c) {
        Human human = null;
        try {
            human = (T) Class.forName(c.getName()).newInstance();
        } catch (Exception e) {
            System.out.println("没生出来");
        }
        return (T) human;
    }
}
```

使用反射获取需要创建人种的对象

5. 使用

```java
public class Main {
    public static void main(String[] args) {
        AbstractHumanFactory factory = new HumanFactory();

        Human yellowHuman = factory.createHuman(YellowHuman.class);
        yellowHuman.getColor();
        yellowHuman.talk();

        Human whiteHuman = factory.createHuman(WhiteHuman.class);
        whiteHuman.getColor();
        whiteHuman.talk();

    }
}
```



## 扩展

### 简单工厂（静态工厂模式）

去掉抽象工厂类，并把HumanFactory的createHuman方法改为静态方法

缺点：不符合开闭原则

### 多工厂类

![1731143239948](https://raw.githubusercontent.com/betteryuxuan/Image/main/1731143239948.jpg)

每个工厂知道自己的职责，创建对应的对象，不需要使用反射，参数了

```java
public abstract class AbstractHumanFactory {
    public abstract Human T createHuman();
}
```

```java
public class WhiteHumanFactory extends AbstractHumanFactory {
    @Override
    public WhiteHuman createHuman() {
        return new WhiteHuman();
    }
}
```

```java
Human whiteHuman = (new WhiteHumanFactory()).createHuman();
```

### 替代单例模式

还没学

### 延迟加载工厂

```java
// 延迟加载工厂类
public class LazyHumanFactory {
    private static final Map<String, Human> humanMap = new HashMap<>();

    public static synchronized Human createHuman(String type) {
        Human human = null;
        if (humanMap.containsKey(type)) {
            human = humanMap.get(type);
        } else {
            if (type.equals("whiteHuman")) {
                human = new WhiteHuman();
            } else {
                human = new YellowHuman();
            }
            humanMap.put(type, human);
        }
        return human;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Human whiteHuman = LazyHumanFactory.createHuman("WhiteHuman");
        Human yellowHuman = LazyHumanFactory.createHuman("YellowHuman");
        whiteHuman.getColor();
        whiteHuman.talk();
        yellowHuman.getColor();
        whiteHuman.talk();
    }
}
```

# 抽象工厂模式

# 建造者模式

也叫生成器模式

> 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

> 举例：组装一个电脑，将部件和组装过程分离，是的构建过程和部件可以自由扩展，两者间耦合度降低

## 角色

* **Product**：产品类

* **Builder**：抽象建造者

  规范产品的组建，一般是由子类实现。

* **ConcreteBuilder**：具体建造者

  实现抽象类定义的所有方法，并且返回一个组建好的对象

* **Director**：导演类

  负责安排已有模块的顺序

## 实现

* Builder

```java
public abstract class Builder {
    public abstract void setPart(String param);
    public abstract Product buildProduct();
}
```

* ConcreateProduct

```java
public class ConcreateProduct extends Builder {
    private Product product = new Product();

    @Override
    public void setPart(String param) {
        this.product.setParam(param);
    }

    @Override
    public Product buildProduct() {
        return product;
    }
}
```

* Director

```java
public class Director {
    private Builder builder = new ConcreateProduct();

    public Product getProduct() {
        builder.setPart("1");
        return builder.buildProduct();
    }
}
```

* Product

```java
public class Product {
    private String param;

    public Product() {
    }

    public Product(String param) {
        this.param = param;
    }

    public String getParam() {
        return param;
    }

    public void setParam(String param) {
        this.param = param;
    }
}
```

## 优点

* 封装性

  使用建造者模式可以使客户端不必知道产品内部组成的细节

* 建造者独立，容易扩展

* 便于控制细节风险

  由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响

## 场景

* 对象创建过程依赖于其他对象且这些依赖的获取较为复杂时，可以通过建造者模式封装创建过程。
* 相同方法，不同执行顺序产生不同结果
* 多个部件可以装配，但结果不同
* 调用顺序不同，产生不同效能





# 结构型设计模式

# 代理模式

**代理模式（Proxy Pattern）** 是一种结构型设计模式，它提供了一个代理对象，控制对目标对象的访问。代理对象通常在客户端与目标对象之间起到中介的作用，用于扩展目标对象的功能。

> **定义**：为其他对象提供一种代理以控制对这个对象的访问

## 示例

定义接口

```java
// 公共接口
public interface IShop {
    void buy();
}
```

实现真实类

```java
// 真实对象
public class Buyer implements IShop{
    @Override
    public void buy() {
        System.out.println("购买");
    }
}
```

定义代理类

```java
// 代理类
public class Buying implements IShop{
    private IShop iShop;

    public Buying(IShop iShop) {
        this.iShop = iShop;
    }

    @Override
    public void buy() {
        iShop.buy();
    }
}
```

测试代码

```java
public class Client {
    public static void main(String[] args) {
        // 创建真实对象
        IShop person1 = new Buyer();
        // 创建代理对象
        IShop proxy = new Buying(person1);
        // 使用代理对象
        proxy.buy();
    }
}
```

## 结构

**Subject（抽象主题）**：定义目标对象和代理对象的公共接口。

**RealSubject（真实主题）**：实现了Subject接口，定义了具体的业务逻辑。

**Proxy（代理）**：代理对象，包含对真实主题的引用，并且可以在对真实主题的调用前后添加额外的功能。

![1733493914683](https://raw.githubusercontent.com/betteryuxuan/Image/main/1733493914683.jpg)

## 分类

1. **静态代理**

静态代理是指在编译时就已经确定代理类的实现，通常是手动编写代理类。静态代理的关键特点是代理类与目标类之间有一一对应的关系。

2. **动态代理**

动态代理是在运行时动态生成代理对象，而不是在编译时就明确写好的。Java提供了**通过反射机制动态的生成代理对象**的机制

## 动态代理

java提供了`java.lang.reflect.InvocationHandler`，一个便捷的动态代理接口，实现它要重写其调用方法`invoke`

```java
// 目标接口
public interface Subject {
    void request();
}

// 目标类
public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("真实主题：处理请求。");
    }
}

// 动态代理的处理器
public class DynamicProxyHandler implements InvocationHandler {
    private Object target;

    public DynamicProxyHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("代理：在真实主题处理请求之前。");
        Object result = method.invoke(target, args);  // 调用目标方法
        System.out.println("代理：在真实主题处理请求之后。");
        return result;
    }
}

// 测试
public class DynamicProxyDemo {
    public static void main(String[] args) {
        // 创建一个真实的目标对象
        RealSubject realSubject = new RealSubject();

        // 使用Proxy创建代理对象
        Subject proxy = (Subject) Proxy.newProxyInstance(
            // 目标类的类加载器
            realSubject.getClass().getClassLoader(),
            
            // 目标类实现的接口
            new Class[] {Subject.class},  
            
            // 代理的处理器（即动态代理的逻辑）
            new DynamicProxyHandler(realSubject)
        );
        
        // 调用代理对象的方法
        proxy.request();
    }
}
```



# 装饰模式

**定义**：

> 动态地向对象添加额外的职责，而不改变其结构。

**使用场景**：

> 需要透明且动态地扩展类的功能时

## 示例

```java
// 抽象组件类
public abstract class Component {
    // 抽象操作方法，由子类实现
    public abstract void operate();
}
```

```java
// 具体组件类
public class ConcreteComponent extends Component {
    @Override
    public void operate() {
        System.out.println("执行基本操作");
    }
}
```

```java
// 装饰者基类
public abstract class Decorator extends Component {
    protected Component component; // 持有组件对象的引用

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operate() {
        component.operate(); // 调用组件的操作
    }
}
```

```java
// 具体装饰者实现类
public class ConcreteDecoratorA extends Decorator {
    public LoggingDecorator(Component component) {
        super(component);
    }

    @Override
    public void operate() {
        System.out.println("开始");
        super.operate(); // 调用原始操作
        System.out.println("结束");
    }
}
```

```java
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        // 创建具体组件
        Component component = new ConcreteComponent();

        // 根据组件对象构造装饰者componentA并调用
        Component componentA = new ConcreteDecoratorA(component);
        componentA.operate();
    }
}
```

![1733658580628](https://raw.githubusercontent.com/betteryuxuan/Image/main/1733658580628.jpg)

## 结构

1. **抽象组件（Component）**： 一个接口或抽象类，被装饰的原始对象
2. **具体组件（ConcreteComponent）**： 抽象组件的具体实现，是被装饰的核心对象
3. **抽象装饰者（Decorator）**： 抽象类或接口，**持有一个组件对象的引用**，并定义与组件一致的接口
4. **具体装饰者（ConcreteDecorator）**： 抽象装饰者实现类，对抽象装饰者做出具体的实现

## 使用场景

1. 动态扩展一个类的功能。
2. 替代多层次的继承结构。
3. 当不能直接修改类或不希望影响其他对象时。

## 与代理模式区别

**装饰模式**：

- **目的**：装饰模式用于动态地扩展一个对象的功能，且对客户端透明。它是继承关系的替代方案，可以通过包装原对象并为其添加新的功能，而不改变原对象的结构。
- **使用场景**：当你需要扩展对象的功能时，不希望直接修改原有的类时

**代理模式**：

- **目的**：代理模式用于为其他对象提供一个替代品或代理对象，以便通过代理对象来控制对原对象的访问。代理对象本身不增强原对象的功能，而是控制访问、延迟加载、安全检查等。
- **使用场景**：当你希望控制对某个对象的访问（例如，延迟加载、访问权限控制、日志记录等）时，可以使用代理模式。

> **装饰模式**强调对对象功能的增强和扩展。
>
> **代理模式**关注对对象的访问控制、管理、替代。
>
> 核心区别：**装饰模式是为了增强原对象的功能，而代理模式是为了控制原对象的访问。**

## Context

![59696fbdc60c2005397adbbcf2f24f7b](https://raw.githubusercontent.com/betteryuxuan/Image/main/59696fbdc60c2005397adbbcf2f24f7b.png)

```java
// 抽象组件
public abstract class Context {
    public abstract void startActivity(@RequiresPermission Intent intent);
    public void startActivity(Intent intent, Bundle options);
}
```

```java
// 具体组件实现类
class ContextImpl extends Context{
    @Override
    public void startActivity(Intent intent) {
        warnIfCallingFromSystemProcess();
        startActivity(intent, null);
    }
    
    @Override
    public void startActivity(Intent intent, Bundle options) {
        warnIfCallingFromSystemProcess();

        final int targetSdkVersion = getApplicationInfo().targetSdkVersion;

        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_NEW_TASK) == 0
            && (targetSdkVersion < Build.VERSION_CODES.N
                || targetSdkVersion >= Build.VERSION_CODES.P)
            && (options == null
                || ActivityOptions.fromBundle(options).getLaunchTaskId() == -1)) {
            throw new AndroidRuntimeException(
                "Calling startActivity() from outside of an Activity"
                + " context requires the FLAG_ACTIVITY_NEW_TASK flag."
                + " Is this really what you want?");
        }
        mMainThread.getInstrumentation().execStartActivity(
            getOuterContext(), mMainThread.getApplicationThread(), null,
            (Activity) null, intent, -1, options);
    }
}
```

```java
// 装饰者，持有ContextImpl的对象
public class ContextWrapper extends Context {
    Context mBase;

    @Override
    public void startActivity(Intent intent) {
        mBase.startActivity(intent);
    }

    @Override
    public void startActivity(Intent intent, @Nullable Bundle options) {
        mBase.startActivity(intent, options);
    }
}
```

```java
Activity extends ContextThemeWrapper
ContextThemeWrapper extends ContextWrapper
```

`Activity`就是具体装饰者

`ContextImpl`的创建和`ContextWrapper`对`ContextImpl`引用在`ActivityThread`的`main`函数中进行

# 外观模式

> 外观模式（Facade Pattern）是一种结构型设计模式，它为复杂的子系统提供一个简单的接口。
>
> 目的是简化系统的使用方式，使得调用者可以通过一个统一的入口来访问系统中的多个子系统，而不需要关心子系统的内部实现细节。

## 结构

外观模式通常包含以下几个角色：

1. **Facade（外观类）**：提供一个简化的接口，委托请求给子系统。

2. **Subsystem（子系统类）**：各个独立的子系统，完成具体的业务逻辑。

![1733665652587](https://raw.githubusercontent.com/betteryuxuan/Image/main/1733665652587.jpg)

## 示例

```java
// 外观类：简化多个功能操作的接口
class SmartphoneFacade {
    private Camera camera = new Camera();
    private MusicPlayer musicPlayer = new MusicPlayer();

    public void takePhotoAndPlayMusic() {
        camera.open();
        camera.takePhoto();
        musicPlayer.play();
    }

    public void stopMusicAndCloseCamera() {
        musicPlayer.stop();
        camera.open(); 
    }
}

// 子系统相机
class Camera {
    public void open() {
        System.out.println("打开相机");
    }

    public void takePhoto() {
        System.out.println("拍照");
    }
}
// 子系统音乐播放器类似

// 客户端
public class FacadePatternExample {
    public static void main(String[] args) {
        SmartphoneFacade smartphone = new SmartphoneFacade();

        smartphone.takePhotoAndPlayMusic();
        smartphone.stopMusicAndCloseCamera();
    }
}
```

使用手机只需要调用相关方法，而不用去管`Camera`和`MusicPlayer`的具体实现

## 使用场景

- 当系统较为复杂时，使用外观模式可以简化与子系统的交互，提供一个更易于使用的接口。
- 为多个子系统提供一个统一的接口。
- 需要解耦子系统与外部代码的依赖关系。

**优点**：

- **简化接口**：隐藏了系统的复杂性，提供了更简单的接口。
- **降低耦合**：客户端与子系统之间的耦合度降低，修改子系统的实现不会影响到客户端。

## Context

> `Context`封装了很多重要的操作，如 `startActivity`、`sendBroadcast`、`bindService` 等。因此，`Context`对开发者来说是最重要的高层接口。`Context`只是一个定义了很多接口的抽象类，这些接口的功能实现并不是在`Context`及其子类中，而是通过其他子系统来完成。
>
> `Context`只是一个抽象类，它的真正实现在`Contextlmpl`类中，`Contextlmpl`就是外观类。

1. **`startActivity()`**：`startActivity()` 方法启动一个新的 `Activity`，但实际的启动过程是通过 `ActivityManagerService` 来完成的。
2. **`sendBroadcast()`**：底层的实现则是通过 `BroadcastManager` 来处理。
3. **`bindService()`**：`bindService()` 方法允许应用与服务建立连接，实际操作是通过 `ServiceManager` 来管理服务的绑定。

# 享元模式

> 享元模式用来尽可能减少内存使用量，它适合用于可能存在大量重复对象的场景，来缓存可共享的对象，达到对象共享、避免创建过多对象的效果，可以提升性能、避免内存移除等。
>
> 核心思想是<u>复用已经存在的对象，而不是每次都创建新对象。</u>

> 享元对象中的部分状态是可以共享，可以共享的状态成为内部状态，内部状态不会随着环境变化；不可共享的状态则称为外部状态，它们会随着环境的改变而改变。
>
> 在享元模式中会建立一个对象容器，在经典的享元模式中该容器为一个 Map，它的键是享元对象的内部状态，它的值就是享元对象本身。客户端程序通过这个内部状态从享元工厂中获取享元对象，如果有缓存则使用缓存对象，否则创建一个享元对象并且存入容器中，这样一来就避免了创建过多对象的问题。

## 结构

1. **抽象享元（Flyweight）**：定义享元对象的基类或接口
2. **具体享元（ConcreteFlyweight）**：实现抽象享元对象
3. **享元工厂（FlyweightFactory）**：用于管理享元对象的创建和共享，确保享元对象的复用。

## 示例

在火车票预订系统中，有很多用户会购买相同类型、相同时间、相同座位的火车票。每次有用户购买相同的火车票时，我们不需要为每个用户创建一个新的火车票对象，而是可以共享相同的火车票对象。享元模式可以帮助我们避免为每个用户创建重复的对象，从而节省内存。

**享元对象（Flyweight）**

`TrainTicket` 类是享元对象，表示火车票的固定信息，例如车次、出发时间、座位类型等。

```java
// 享元类：火车票
public class TrainTicket {
    private String trainNumber; // 车次
    private String departureTime; // 出发时间

    // 构造方法，初始化火车票的固定信息
    public TrainTicket(String trainNumber, String departureTime) {
        this.trainNumber = trainNumber;
        this.departureTime = departureTime;
    }

    // 购票
    public void serve(String passengerName) {
        System.out.println("乘车人：" + passengerName + " ，车次 " + trainNumber +
                           "，发车时间: " + departureTime);
    }
}
```

**享元工厂（FlyweightFactory）**

`TrainTicketFactory` 类是享元工厂，用于管理和共享火车票对象。

```java
public class TrainTicketFactory {
    private Map<String, TrainTicket> ticketMap = new HashMap<>();

    public TrainTicket getTrainTicket(String trainNumber, String departureTime) {
        String key = trainNumber + departureTime;
        if (!ticketMap.containsKey(key)) {
            ticketMap.put(key, new TrainTicket(trainNumber, departureTime));
            System.out.println("购票成功，乘车人：" + trainNumber + ", 车次: " + departureTime);
        }
        return ticketMap.get(key); // 返回共享的火车票对象
    }
}
```

 **客户端**

```java
public class TrainStation {
    public static void main(String[] args) {
        TrainTicketFactory ticketFactory = new TrainTicketFactory();

        TrainTicket ticket1 = ticketFactory.getTrainTicket("G101", "10:00");
        TrainTicket ticket2 = ticketFactory.getTrainTicket("G101", "10:00");
        TrainTicket ticket3 = ticketFactory.getTrainTicket("D202", "14:00");

        ticket1.serve("Alice");
        ticket2.serve("Bob");
        ticket3.serve("Charlie");
    }
}
```

* **`TrainTicket`** 类是享元对象，火车票的固定信息，相同的，可以被多个乘客共享。
* **`TrainTicketFactory`** 类是享元工厂，维护了一个火车票对象池，确保每种车次、出发时间和座位类型的火车票只创建一次。如果有相同的请求，返回已有的火车票对象。
* **`TrainStation`** 类模拟了多个乘客购买相同车次、相同时间的火车票。由于使用了享元模式，虽然有多个乘客，但共享了相同的火车票对象。

## 使用场景

1. 对象创建代价高，且每个对象的内部状态差别不大。
2. 需要优化程序性能，减少内存消耗。

![IMG_20241208_205403](https://raw.githubusercontent.com/betteryuxuan/Image/main/IMG_20241208_205403.jpg)

## Message

在Handler中，使用**对象池**来管理 `Message` 对象，能够有效避免频繁的对象创建，减少内存占用和GC频率。

```java
public final class Message implements Parcelable {
    Message next;
    // 同步锁的对象
    public static final Object sPoolSync = new Object();
    // 对象池的头部，具体实现是链表
    private static Message sPool;
    // 当前池中存储的 Message 对象数量
    private static int sPoolSize = 0;
    // 对象池的最大容量
    private static final int MAX_POOL_SIZE = 50;

    public static Message obtain() {
        // 线程安全
        synchronized (sPoolSync) {
            if (sPool != null) {
                // 从池中取出一个 Message 对象
                Message m = sPool;
                // 更新池的头部为下一个对象
                sPool = m.next;
                // 清空当前 Message 对象的链表连接，避免不必要的引用
                m.next = null;
                // 清除消息的标志位，表示该对象已被重用
                m.flags = 0;
                // 更新池中存储的对象数量
                sPoolSize--;
                return m;
            }
        }
        // 如果池中没有可复用的对象，创建一个新的 Message 对象并返回
        return new Message();
    }
    
   /**
     * 回收该 Message 对象，准备将其放入对象池中。
     * 该方法会检查 Message 是否还在使用中，若仍在使用则抛出异常。
     */
    public void recycle() {
        if (isInUse()) {  
            if (gCheckRecycle) {  
                throw new IllegalStateException("This message cannot be recycled because it "
                        + "is still in use.");
            }
            return;  
        }
        recycleUnchecked();
    }

    /**
     * 实际进行回收操作，将该对象状态清空，并加入对象池中以供复用。
     */
    void recycleUnchecked() {
        // 清除对象的各个字段，确保该对象回收后不再持有任何引用
        flags = FLAG_IN_USE;
        what = 0;
        arg1 = 0;
        arg2 = 0;
        obj = null;
        replyTo = null;
        sendingUid = UID_NONE;
        workSourceUid = UID_NONE;
        when = 0;
        target = null;
        callback = null;
        data = null;

        synchronized (sPoolSync) {  
            if (sPoolSize < MAX_POOL_SIZE) {  
                next = sPool;  
                sPool = this;  
                sPoolSize++;  
            }
        }
    }
}
```

`Message` 类承担了三个职责：

1. **Flyweight 抽象角色**：提供了统一的接口来处理对象的共享和复用。
2. **ConcreteFlyweight 具体享元角色**：实际存储对象的状态并处理业务逻辑。
3. **FlyweightFactory 工厂角色**：管理对象池，复用和回收 `Message` 对象。

# 行为型设计模式

# 策略模式

**策略模式**（Strategy Pattern）是行为型设计模式之一，主要用于定义一组算法，将每个算法封装起来，并使它们可以相互替换，从而让算法的变化独立于使用算法的客户代码。

## 结构

1. **Context（上下文角色）**

上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。

2. **Strategy（抽象策略角色）**

- 定义所有支持的算法的通用接口，由具体策略实现。

3. **ConcreteStrategy（具体策略角色）**

- 实现 `Strategy` 接口的具体算法。

![1733744300351](https://raw.githubusercontent.com/betteryuxuan/Image/main/1733744300351.jpg)

## 示例

**抽象策略接口**

```java
public interface Strategy {
    //策略模式的运算法则
    public void doSomething();
}
```

**具体策略实现**

```java
public class ConcreteStrategy1 implements Strategy {
    public void doSomething() {
        System.out.println("具体策略1的运算法则");
    }
}

public class ConcreteStrategy2 implements Strategy {
    public void doSomething() {
        System.out.println("具体策略2的运算法则");
    }
}
```

**上下文角色**

```java
public class Context {
    private Strategy strategy = null;
    public Context(Strategy _strategy){
        this.strategy = _strategy;
    }
    
    public void doAnythinig(){
        this.strategy.doSomething();
    }
}
```

**测试代码**

```java
public class Client {
    public static void main(String[] args) {
        Strategy strategy = new ConcreteStrategy1();
        Context context = new Context(strategy);
        context.doAnythinig();
    }
}
```

## 策略枚举

策略枚举的核心思想是将一组相关的策略逻辑封装为枚举类型，以便于在运行时动态选择适当的策略。这种模式特别适用于算法选择、配置切换、行为控制等场景。

```java
public enum Calculator {
    //加法运算
    ADD("+"){
        public int exec(int a,int b){
            return a+b;
        }
    },
    //减法运算
    SUB("-"){
        public int exec(int a,int b){
            return a - b;
        }
    };
    String value = "";
    //定义成员值类型
    private Calculator(String _value){
        this.value = _value;
    }
    //获得枚举成员的值
    public String getValue(){
        return this.value;
    }
    //声明一个抽象函数
    public abstract int exec(int a,int b);
}
```

 ```java
 public class Main {
     public static void main(String[] args) {
         int a = 10, b = 5;
 
         // 使用加法运算
         System.out.println("加法结果: " + Calculator.ADD.exec(a, b)); // 输出：15
 
         // 使用减法运算
         System.out.println("减法结果: " + Calculator.SUB.exec(a, b)); // 输出：5
 
         // 获取枚举的值
         System.out.println("加法符号: " + Calculator.ADD.getValue()); // 输出：+
         System.out.println("减法符号: " + Calculator.SUB.getValue()); // 输出：-
     }
 }
 ```

策略枚举受枚举类型的限制，每个枚举项都是public、final、static的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色

## 使用场景

- 需要动态选择算法或行为。
- 一个类定义了多种行为，而这些行为在不同情况下会被调用。
- 避免使用过多的 `if-else` 或 `switch-case`。

**优点**

1. **开放-关闭原则**：可以自由扩展新算法，而无需修改现有代码。
2. **减少复杂条件语句**：避免了冗长的 `if-else` 或 `switch-case`。
3. **提高代码的可维护性**：策略类各自独立，职责单一。

**缺点**

1. **增加类的数量**：每个策略都需要定义为一个单独的类。
2. **上下文角色和具体策略紧耦合**：策略模式的灵活性依赖于正确配置。

# 模板方法模式

模板方法模式（Template Method Pattern）是一种行为设计模式，它定义了一个算法的框架，而将某些步骤的实现延迟到子类中。模板方法模式允许子类在不改变算法结构的情况下重新定义算法的某些步骤。

## 结构

1. **抽象类（AbstractClass）**
   - 定义算法的骨架。
   - 声明一些抽象方法，要求子类实现。
   - 可以包含一些默认实现的方法。
2. **具体子类（ConcreteClass）**
   - 实现抽象类中定义的抽象方法。
   - 可以根据需求覆盖抽象类中已实现的方法。
3. **模板方法（Template Method）**
   - 是在抽象类中定义的具体方法，用来调度抽象方法和其他具体方法，形成一个完整的算法框架。
   - 一般会用 `final` 修饰以防止子类重写。

## 示例

```java
// 抽象类
abstract class Beverage {
    // 模板方法，定义制作饮品的算法骨架
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }

    // 具体方法：烧水
    private void boilWater() {
        System.out.println("烧水");
    }

    // 抽象方法：冲泡
    protected abstract void brew();

    // 具体方法：倒入杯中
    private void pourInCup() {
        System.out.println("倒入杯中");
    }

    // 抽象方法：添加调料
    protected abstract void addCondiments();
}

// 具体类：制作咖啡
class Coffee extends Beverage {
    @Override
    protected void brew() {
        System.out.println("冲咖啡");
    }

    @Override
    protected void addCondiments() {
        System.out.println("添加糖和奶");
    }
}

// 具体类：制作茶
class Tea extends Beverage {
    @Override
    protected void brew() {
        System.out.println("冲茶");
    }

    @Override
    protected void addCondiments() {
        System.out.println("加柠檬");
    }
}

// 测试类
public class TemplateMethodExample {
    public static void main(String[] args) {
        Beverage coffee = new Coffee();
        coffee.prepareRecipe();

        System.out.println();

        Beverage tea = new Tea();
        tea.prepareRecipe();
    }
}
```

## 钩子方法

> 钩子方法（Hook Method）是指在类或框架中定义的一些方法，这些方法通常有默认实现，或者不做任何操作，允许子类在特定时机插入自定义逻辑，从而改变默认行为或扩展功能。
>
> 目的是提供一些扩展点，使得子类可以灵活地插入自定义代码，而不需要重写整个算法。

在模板方法模式中，父类通常会定义一个模板方法，该方法定义了算法的骨架和步骤，而子类可以通过覆写某些步骤来实现具体的操作。钩子方法则是模板方法中的一种特殊形式，它是**可选**的，不一定需要重写，通常有默认实现。

**作用**

- **默认行为**：钩子方法通常有默认实现，不强制子类实现。
- **可选行为**：子类可以选择是否重写钩子方法来改变某些行为。
- **流程控制**：钩子方法在流程的特定时刻被调用，用于控制执行的流程，或者在某些条件下改变流程的执行。

**示例**

```java
abstract class Beverage {
    public final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        if (customerWantsCondiments()) {
            addCondiments();
        }
    }

    private void boilWater() {
        System.out.println("烧水");
    }

    protected abstract void brew();

    private void pourInCup() {
        System.out.println("倒入杯中");
    }

    // 钩子方法：是否添加调料
    protected boolean customerWantsCondiments() {
        return true;  // 默认实现，返回true表示默认添加调料
    }

    protected abstract void addCondiments();
}

class Coffee extends Beverage {
    @Override
    protected void brew() {
        System.out.println("冲咖啡");
    }

    @Override
    protected void addCondiments() {
        System.out.println("添加糖和奶");
    }

    // 重写钩子方法：默认选择不加调料
    @Override
    protected boolean customerWantsCondiments() {
        return false; 
    }
}

// 测试类
public class TemplateMethodExample {
    public static void main(String[] args) {
        Beverage coffee = new Coffee();
        coffee.prepareRecipe();
    }
}
```

## 使用场景

1. **多个子类有公有的方法，且逻辑基本相同**
2. **重要、复杂的算法设计为模板方法，周边的细节功能由子类实现**
3. **重构时，模板方法模式常用于抽取公共部分代码，并通过钩子函数约束行为**

**优点**

1. **封装不变部分，扩展可变部分**
2. **提取公共部分代码，便于维护**
3. **行为由父类控制，子类实现**

**缺点**

1. **子类依赖**：增加了子类的实现复杂度，必须实现抽象方法。
2. **限制灵活性**：算法的整体结构是固定的，子类只能修改部分步骤。











































































---

 

---



> 参考：
>
> 1. 《设计模式之禅》
> 2. 《Android进阶之光》
> 3. 《Android源码设计模式解析与实战》
